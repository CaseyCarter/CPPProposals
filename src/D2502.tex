% !TeX program = luatex
% !TEX encoding = UTF-8

\RequirePackage{luatex85}%
\documentclass{wg21}
\usepackage{threeparttable}
\usepackage{adjustbox}
\usepackage{xcolor,colortbl}
\usepackage{array}
\newcolumntype{?}{!{\vrule width 1pt}}

\title{\tcode{std::generator}: Synchronous Coroutine Generator for Ranges}
\docnumber{D2502R2}
\audience{LEWG}
\author{Casey Carter}{Casey@Carter.net}
%% \authortwo{Lewis Baker}{lewissbaker@gmail.com}
%% \authorthree{Corentin Jabot}{corentin.jabot@gmail.com}

\begin{document}
\maketitle

\section{Abstract}

We propose a standard library type \tcode{std::generator}
which implements a coroutine generator
that models \tcode{std::ranges::input_range}.

\section{Acknowledgements}

I'd like to thank Lewis Baker and Corentin Jabot,
whose P2168 \cite{P2168R3} I looted shamelessly for this proposal.
This paper is presented as a new revision of
their unpublished D2168R4 for continuity of design.

\section{Revisions}

%% TODO:
%% * Allow yielding lvalues for generator<T> but not generator<T&&>.
%% * Give "unspecified type whose size and alignment are both
%%   __STDCPP_DEFAULT_NEW_ALIGNMENT__" a user-accessible name.

\subsection{D2502R2}
Changes made at the request of LWG small group review except those annotated
[CMC].
\begin{itemize}
\item Rebase onto N4910.
\item{} [CMC] Change directions to the Editor from blue ``Drafting Note'' to
  magenta ``Editor's note'' in square brackets. Hopefully this makes them
  distinctive so as not to be confused with the actual wording changes.
\item Changes to wording for \tcode{elements_of}:
  \begin{itemize}
    \item Don't present as a subclause that holds a single subclause; flatten.
    \item{} [CMC] Don't reuse the same input range in the example, which could
      result in undefined behavior with some input ranges. Instead add a
      \tcode{bool} template parameter that selects between the two different
      uses with \tcode{if constexpr}.
    \item{} [CMC] Annotate member \tcode{range}
      with \tcode{[[no_unique_address]]}
      because a range type \emph{could} be empty
      even if they typically are not.
  \end{itemize}
\item Editorial clarifications in [coroutine.generator.overview]:
  \begin{itemize}
    \item Change ``it was returned from'' to ``from which it was returned.''
    \item Strike the sentence that redundantly describes how \tcode{co_yield}
      works.
    \item Change ``element of the generator'' to ``element of the sequence.''
    \item Rename the \tcode{iota} generator in the example to \tcode{ints}
      to avoid confusion with \tcode{std::iota}, \tcode{std::ranges::iota_view},
      and \tcode{std::ranges::views::iota}.
  \end{itemize}
\item \tcode{<generator>} no longer explicitly includes
  \tcode{<coroutine>} and \tcode{<ranges>}.
\item Rename \tcode{generator}'s first template parameter
  from \tcode{R} to \tcode{Ref} to avoid confusion with range parameters which
  are usually \tcode{R}.
\item Unify all "Mandates" conditions on \tcode{generator}'s template parameters
  into a single bulleted list.
\item Express the type requirement on \tcode{generator}'s \tcode{Allocator}
  template parameter as a precondition.
\item Replace all occurrences (all instances?) of ``instance'' in the wording
  (primarily ``generator instance'' becomes ``generator object'').
\item The notional stack of coroutines
  associated with a generator object
  is now a notional stack of coroutine handles.
\item Simplify the specification of \tcode{generator}'s assignment operator:
  it now takes a \tcode{generator} argument by-value and swaps coroutine handles
  between \tcode{*this} and the argument. (Usage should be equivalent to the
  prior formulation.)
\item "Initial suspend point" has no hyphens, and
  is defined in [dcl.fct.def.coroutine].
\item We don't need to emphasize that the stack is empty in \tcode{begin}.
\item Corrected spelling of \tcode{__STDCPP_DEFAULT_NEW_ALIGNMENT__}.
\item{} [CMC] Coalesce privates into a single section at:
  \begin{itemize}
    \item the beginning of \tcode{generator}'s body, and
    \item the end of \tcode{promise_type}'s body.
  \end{itemize}
\item Clarify behavior of \tcode{promise_type::final_suspend}, especially when
  the stack of associated coroutine handles becomes empty.
\item Rename template parameter \tcode{Alloc2} of \tcode{promise}'s
  \tcode{yield_value(elements_of)} member function template to \tcode{Alloc}.
\item \tcode{get_return_object} returns \tcode{generator(...)} instead of
  \tcode{generator\{...\}}.
\item Massively simplify and un-template the \tcode{yield_value} overload that
  takes \tcode{const remove_reference_t<yielded>\&}. (We don't need to
  artificially template to ensure it's distinct from
  \tcode{yield_value(yielded)}, the added constraints make it distinct
  even when \tcode{yielded} is a \tcode{const} lvalue reference.)
\item In the description of the \tcode{yield_value}
  overload that takes \tcode{elements_of<generator<...},
  remove the metasyntactic variable \tcode{r}
  that refers to "an lvalue denoting the \tcode{generator}
  referenced by \tcode{g.range}".
  \tcode{g.range} is already such an lvalue, just use it directly.
  Use the language "stored exception" instead of "captured exception"
  to avoid any possible confusion with lambda captures.
  Strike the ``Variables with automatic storage duration'' note
  as extraneous.
\item In the description of the \tcode{yield_value}
  overload that takes \tcode{elements_of<Rng},
  similarly use \tcode{r.range} directly
  instead of defining \tcode{rng} as an identical lvalue.
  In the ``effects equivalent to'' code,
  define a local name for \tcode{range_reference_t<Rng>}
  and use that instead of \tcode{auto} and \tcode{decltype(e)}.
\item Specify that \grammarterm{yield-expression}s that call
  one of the \tcode{promise::yield_value} overloads
  have type \tcode{void}.
\item Remove extraneous \tcode{static} from all declarations
  of class-member \tcode{operator new} and \tcode{operator delete};
  class-member \tcode{operator new} and \tcode{operator delete}
  are \tcode{static} members regardless.
\item Merge the specifications of the \tcode{operator new} overloads
  into a single specification.
\item Fix precondition on \tcode{\exposid{iterator}::operator*()} and
  \tcode{\exposid{iterator}::operator++()}.
\item Remove precondition from \tcode{\exposid{iterator}::operator++(int)}
  which is extraneous thanks to "Effects: equivalent to".
\item Make \tcode{operator==} a hidden friend instead of a member
  for consistency with the rest of the library.
  [CMC] Also use "Effects: equivalent to" for \tcode{operator==}
  to avoid explicit preconditions.
\item Strike a couple of \tcode{friend sometype} declarations.
\item Strike exposition-only constructors.
\item Coroutine handles do not "denote" coroutines,
  they "refer to" coroutines ([expr.await]/3.5 is the first of many usages).
\item{} [CMC] Define the nested classes within \tcode{std::ranges}.
\item{} [CMC] Update implementation.
\end{itemize}

\subsection{P2502R1}
\begin{itemize}
\item The type \tcode{generator::yielded}
  is now publicly-visible and not exposition-only
  per 2021-12-13 LEWG discussion.
\item Feature-test macro insertion is now
  ordered properly with the other wording.
\item Coroutines for \tcode{generator<T\&\&>} can now yield lvalues;
  the generated element is an xvalue denoting a copy of the lvalue.
  This saves folks the trouble of writing \tcode{co_yield auto(lval\-ue)}
  instead of \tcode{co_yield lvalue}.
\item Reorder \tcode{generator}'s template parameters
  (again, for the last last time).
  Coroutine Task Force discussions convinced all participants
  (including the author) that it was too big a break with
  the rest of the Standard Library to have the \tcode{Allocator} not be
  the final template parameter.
\item Simplify \tcode{elements_of} into a vanilla two-element \tcode{struct}.
\item Update implementations accordingly.
\item Per 2022-01-025 LEWG direction, \tcode{generator<T>}
  now behaves like \tcode{generator<T\&\&>}
  instead of like \tcode{generator<const T\&>}
  per the design in P2529R0 \cite{P2529R0}.
\end{itemize}

\subsection{P2502R0}
\begin{itemize}
\item Reorder \tcode{generator}'s template parameters.
  This allows the reference type to be
  more easily defaulted to a true reference,
  while still respecting requests for
  differing value and reference types.
  This preserves the previous design's ease-of-use,
  while providing full generality.
\item Remove concerns about the $\bigoh{1}$ destruction requirement for \tcode{view},
  which has been relaxed by P2415R2 ``What is a view?'' \cite{P2415R2}.
\end{itemize}

\subsection{D2168R4}
\begin{itemize}
\item Wording improvements
\end{itemize}

\subsection{P2168R3}
\begin{itemize}
\item Wording improvements
\end{itemize}

\subsection{P2168R2}
\begin{itemize}
\item Some wording fixes
\item Improve the section on allocator support
\item Updated implementation
\end{itemize}

\subsection{P2168R1}
\begin{itemize}
\item Add benchmarks results and discussion about performance
\item Introduce \tcode{elements_of} to avoid ambiguities when a generator is convertible to the reference type of the parent generator.
\item Add allocator support
\item Symmetric transfer works with generators of different value / allocator types
\item Remove \tcode{\exposid{iterator}::operator->}
\item Put \tcode{generator} in a new \tcode{<generator>} header.
\item Add an other example to motivate the \tcode{Value} template parameter
\end{itemize}


\section{Example}

\begin{colorblock}
    std::generator<int> fib() {
        auto a = 0, b = 1;
        while (true) {
            co_yield std::exchange(a, std::exchange(b, a + b));
        }
    }

    int answer_to_the_universe() {
        auto rng = fib() | std::views::drop(6) | std::views::take(3);
        return std::ranges::fold_left(std::move(range), 0, std::plus{});
    }
\end{colorblock}


\section{Motivation}

C++ 20 had very minimalist library support for coroutines.
Synchronous generators are an important use case for coroutines,
one that cannot be supported
without the machinery presented in this paper.
Writing an efficient recursive generator is non-trivial;
the standard should provide one.


\section{Design}

While the proposed \tcode{std::generator} interface is fairly straightforward, a few decisions are worth pointing out.

\subsection{\tcode{input_view}}

\tcode{std::generator} is a move-only \tcode{view} which models \tcode{input_range} and has move-only iterators.
This is because the coroutine state is a unique resource (even if the coroutine \textit{handle} is copyable).


\subsection{Header}

Multiple options are available as to where to put the \tcode{generator} class.

\begin{itemize}
\item \tcode{<coroutine>}, but \tcode{<coroutine>} is a low level header,
  and \tcode{generator} depends on bits of \tcode{<type_traits>} and \tcode{<iterator>}.

\item \tcode{<ranges>}

\item A new \tcode{<generator>}
\end{itemize}

This paper uses a new \tcode{<generator>} header since P2168R3 did so,
and LEWG has provided no guidance to do otherwise.
We do note on our MSVC STL branch implementation that
\tcode{\#include<ranges>} includes ~52.6k lines of code, and
\tcode{\#include<generator>} ~53.3k lines.
(Note that \tcode{<generator>} is specified to include
both \tcode{<ranges>} and \tcode{<coroutines>}.)
Defining \tcode{generator} in \tcode{<ranges>}
together with a \tcode{\#include<coroutine>}
would penalize people who want \tcode{<ranges>}
but not \tcode{generator} by about 610 LoC.

\section{Reference type}

\tcode{generator} has 3 template parameters: \tcode{generator<R, V = void, Allocator = void>}

From \tcode{R} and \tcode{V}, we derive types:
\begin{codeblock}
using Value = conditional_t<is_void_v<V>, remove_cvref_t<R>, V>;}
using Reference = conditional_t<is_void_v<V>, R&&, R>;
using Yielded = conditional_t<is_reference_v<Reference>, Reference, const Reference&>;
\end{codeblock}

\begin{itemize}
\item \tcode{Value} is a cv-unqualified object type that specifies the value type
  of the \tcode{generator}'s range and iterators,
\item \tcode{Reference} specifies the reference type
  (not necessarily a core language reference type)
  of the \tcode{generator}'s range and iterators, and
\item \tcode{Allocator} is the type of allocator used for the coroutine state,
  which can be \tcode{void} to type-erase
  any allocator specified as a coroutine argument,
  defaulting to \tcode{allocator<byte>} when none is specified.
\item \tcode{Yielded} (necessarily a reference type)
  is the type of the parameter to
  the primary overload of \tcode{yield_value}
  in the generator's associated promise type.
\end{itemize}

\subsection{\tcode{generator<meow>}}
Our expectation is that 98\% of use cases
will need to specify only one parameter.
The resulting generator:
\begin{itemize}
\item has a value type of \tcode{remove_cvref_t<meow>}
\item has a reference type of \tcode{meow},
  if it is a reference type,
  or \tcode{meow\&\&} otherwise,
\item expects \tcode{co_yield} to appear in the body of the generator
  with operands that are convertible to the reference type, and
\item can use any allocator (via type-erasure)
  defaulting to \tcode{allocator<byte>}.
\end{itemize}

This avoids the performance pitfall from
earlier revisions of the proposal
that used the first argument type directly as reference type;
users who naively chose \tcode{generator<std::string>}
got an iterator that produces independent copies
of the yielded value on every dereference,
when they may have been satisfied by
yielding a reference to the same constant value.

As a nod to ease of use, and to more readily reflect the semantics of
prvalue-returning functions, we allow yielding lvalues from generators
with an rvalue reference type when the lvalue is copyable. The result is that
the yielded lvalue is copied into temporary storage, and an iterator for the
generator will return an xvalue denoting that copy when dereferenced.

\subsection{\tcode{generator<meow, woof>}}
For the rare user who needs \tcode{generator}
to step outside the box and use a proxy reference type,
or who needs to generate a range whose iterators yield
prvalues for whatever reason, we have two-argument \tcode{generator}.
If \tcode{woof} is \tcode{void}, this is \tcode{generator<meow>}.
Otherwise, the resulting generator:
\begin{itemize}
\item has a value type of \tcode{woof},
\item has a reference type of \tcode{meow},
\item expects \tcode{co_yield} to appear in the body of the generator
  with operands that are convertible to \tcode{meow}, if it is reference type,
  and otherwise \tcode{const meow\&}, and
\item can use any allocator (via type-erasure) if \tcode{woof} is \tcode{void},
  or otherwise can use any allocator convertible to \tcode{woof}.
\end{itemize}
Your iterators can yield a prvalue, but
it must be a prvalue of \libconcept{copy_constructible} type so a copy of
the operand of a single \tcode{co_yield} can be returned multiple times
from repeated dereferences of the same iterator value.

\subsection{\tcode{generator<meow, woof, quack>}}
For use cases that want to specify an allocator type statically
so they need not constantly pass pairs of
\tcode{allocator_arg, my_allocator} arguments to every coroutine,
we have three-argument \tcode{generator}.
The resulting generator can use any allocator convertible to \tcode{quack},
defaulting to a default-constructed \tcode{woof}
if it is \libconcept{default_initializable}.
The value, reference, and yielded types are
as described for \tcode{generator<meow>}
if \tcode{woof} is \tcode{void}, and
as described for \tcode{generator<meow, woof>} otherwise.

Our expectation is that libraries that wish to declare
many functions with the same statically-specified allocator type
will define a template alias like
\begin{codeblock}
template <class R, class V = void>
using my_generator = generator<R, V, my_allocator>;
\end{codeblock}
to ease declarations.
In practice, this should mean \tcode{generator<R, void, my_allocator>}
(with an explicit second argument of \tcode{void})
appears quite rarely in real code.

\subsection{\tcode{Allocator = void}}

In the 2022-01-13 Coroutine Task Force meeting,
Lewis Baker brought up that LEWG feedback on some revision of P2168
had expressed dissatisfaction with the use of
\tcode{void} to indicate ``type-erase any allocator.''
We discussed some alternatives:
\begin{itemize}
\item Devise a new type for this specific purpose.
  We felt that single-use tag types have low return-on-investment;
  every such tag type consumes a few more bytes of memory
  in nearly every compilation, and a few more neurons of memory
  in every programmer.

\item Reuse an existing type for this purpose.
  \tcode{void} has the advantage that it can never be confused for
  a conforming allocator type, even if it someday does become
  a regular type.
  \tcode{void} requires no predeclaration, and
  no memory is is expended to store its definition.

  \tcode{monostate} was another suggestion that was universally reviled;
  that type already has a very clear purpose in the Standard Library that
  we didn't feel inclined to muddle.

  No one suggested another type that we found to be an improvement.
\end{itemize}
Our conclusion was that we didn't find
the use of \tcode{void} for this purpose confusing,
we were happy to keep it given that more-recent LEWG discussion
had resulted in no further feedback on this topic.

\subsection{Obsolete discussion about reference specification}

\begin{note}
Before P2502R0, \tcode{generator}'s first parameter
\tcode{Type} denoted the reference type of the range / iterators, and
the value type was defaulted to \tcode{remove_cvref_t<Type>}.
The following sections of design discussion from that era
are preserved here.
\end{note}

In earlier versions of this paper,
the reference type was exactly the first template parameter.
This had the advantage of being simple.
But it was a terrible performance trap:

Consider the behavior of the following code assuming the reference type is exactly the first template argument:

\begin{colorblock}
std::generator<std::string> f() {
    std::string hello = "hello";
    co_yield hello;   // 0 or 1 copy depending on implementation
    co_yield "Hello"; // 1 copy (conversion from const char* to std::string)
}

for (auto&& str : f()) {} // 1 copy (*it returns std::string)
\end{colorblock}

Of course the solution, which we advocated for, is for the user to manually specify an explicit reference type:

\begin{colorblock}
    generator<const std::string&> f() {
        std::string hello = "hello";
        co_yield hello;   // 0 or 1 copy depending on implementation
        co_yield "Hello"; // 1 copy (conversion from const char* to std::string)
    }

    for (auto&& str : f()) {} // 0 copy
\end{colorblock}

This works, can be explained, and is even logical. You get what you asked for.
It is nonetheless surprising for non-experts that using the simple \tcode{generator<string>} would create 2 copies per \tcode{co_yield}.

To hope users would not routinely forget
to use a reference type when using \tcode{std::generator}
calls for a heaping barrel of optimism.

We later proposed that for a \tcode{generator<T>},
its reference type be \tcode{conditional_t<is_reference_v<T>, T, const T\&>}.

\newcommand{\cellif}{\cellcolor{red!25}Ill-formed}
\newcommand{\cellid}{\cellcolor{red!70}Ill-formed}
\newcommand{\cellbl}{\cellcolor{green!70}0}
\newcommand{\cellzr}{\cellcolor{green!25}0}
\newcommand{\cellon}{\cellcolor{orange!25}1}


\begin{tabular}{|c|c|c|c|}
\hline
First parameter       & reference type        & default value & can yield mutable lvalue ref? \\ \hline
\tcode{int}           & \tcode{const int\&}   & \tcode{int}   & No                            \\ \hline
\tcode{const int\&}   & \tcode{const int\&}   & \tcode{int}   & No                            \\ \hline
\tcode{int\&}         & \tcode{int\&}         & \tcode{int}   & Yes                           \\ \hline
\tcode{int\&\&}       & \tcode{int\&\&}       & \tcode{int}   & No                            \\ \hline
\tcode{const int\&\&} & \tcode{const int\&\&} & \tcode{int}   & No                            \\ \hline
\end{tabular}

Attempts have been made to characterize the exact relations between reference, value, storage, and \tcode{co_yield} exception types and categories.
Ultimately, a simpler mental model is to characterize what expressions can be yielded for a given reference type and how many copies are made for each scenario.

\begin{tabular}{|c|c|c|c|c|}
\hline
First parameter & \tcode{co_yield const T\&} & \tcode{co_yield T\&} & \tcode{co_yield T\&\&} & \tcode{co_yield U\&\&} \\ \hline
\tcode{T}           & \cellbl & \cellbl & \cellbl & \cellon \\ \hline
\tcode{const T\&}   & \cellzr & \cellzr & \cellzr & \cellon \\ \hline
\tcode{T\&}         & \cellif & \cellzr & \cellif & \cellif \\ \hline
\tcode{T\&\&}       & \cellif & \cellif & \cellzr & \cellon \\ \hline
\tcode{const T\&\&} & \cellif & \cellif & \cellzr & \cellon \\ \hline
\end{tabular}

In this table, we see that only \tcode{co_yield} that requires conversion incurs copy, which is expected.
Coroutines guarantee that the yielded expression exceeds the lifetime of the \tcode{co_yield} expression,
so \tcode{generator} can usefully store
a pointer to the object denoted by a yielded xvalue.

\tcode{co_yield} expressions involving conversion can store the yielded value in an awaiter.
The type of the stored expression is the reference type with its reference qualifiers stripped, but that is an implementation
detail that is not observable and is therefore of limited interest. Of course, that type needs to be constructible from yielded values.

Besides the \tcode{T} case, this behaves very much like returning from a function that is intended.

\subsubsection{Move-only and immovable types}
LEWG was interested in how this works with \tcode{generator} of move-only and immovable types.

\begin{tabular}{|c|c|c|c|}
\hline
First parameter & \tcode{co_yield const T\&} & \tcode{co_yield T\&} & \tcode{co_yield T\&\&} \\ \hline
\tcode{move_only}           & \cellbl & \cellbl & \cellbl \\ \hline
\tcode{const move_only\&}   & \cellzr & \cellzr & \cellzr \\ \hline
\tcode{move_only\&}         & \cellif & \cellzr & \cellif \\ \hline
\tcode{move_only\&\&}       & \cellif & \cellif & \cellzr \\ \hline
\tcode{const move_only\&\&} & \cellif & \cellif & \cellzr \\ \hline \hline

\tcode{immovable}           & \cellbl & \cellbl & \cellbl \\ \hline
\tcode{const immovable\&}   & \cellzr & \cellzr & \cellzr \\ \hline
\tcode{immovable\&}         & \cellif & \cellzr & \cellif \\ \hline
\tcode{immovable\&\&}       & \cellif & \cellif & \cellzr \\ \hline
\tcode{const immovable\&\&} & \cellif & \cellif & \cellzr \\ \hline
\end{tabular}

As that table shows, these types work exactly like other types.
However, to be able to move from a move only reference type, the coroutine has to explicitely state so:

\begin{colorblock}
auto f = []() -> std::generator<move_only> { co_yield move_only{}; }();
for (auto&& x : f) {
    move_only mo = std::move(x); // ill-formed, decltype(x) is const move_only&
}

auto f = []() -> std::generator<move_only&&> { co_yield move_only{}; }();
for (auto&& x : f) {
    move_only mo = x; // ok
}

auto f = []() -> std::generator<move_only&> { move_only m; co_yield m; }();
for (auto&& x : f) {
    move_only mo = std::move(x); // dicey but okay
}
\end{colorblock}

\subsection{Potential downsides}
\begin{colorblock}
auto f = []() -> std::generator<MyType> {
    MyType t;
    co_yield std::move(t);
}();
\end{colorblock}

In the example above \tcode{std::move} doesn't move. Arguably more than usual.
Indeed the code expands to something similar to:

\begin{colorblock}
auto&& __temp = std::move(t);
yield_value(_temp); // <=> promise.value = std::addressof(__temp); // no move
\end{colorblock}

Of course, a move would not have occurred for a \tcode{std::generator<const MyType\&>} either as these things are identical.
It might be suprising?
The only way to avoid that is to create temporary value for rvalue reference, which would force a move to actually occurs,
at the cost of performance.

\subsubsection{Alternatives considered}

\paragraph{Mandating a reference as the first parameter}

We could make \tcode{generator<int>} ill-formed and force people to specify a reference type like \tcode{generator<const int\&>}.
We do not think this is very user-friendly, given that we can provide a reasonable default.

We rejected this option.

\paragraph{Using \tcode{T\&} as the default}

There are two issues with mutable references:
\begin{itemize}
\item They are mutable (They allow mutating the coroutine frame), which would be an \emph{interesting} default.
\item They are very restrictive as to the set of \tcode{co_yield} expression allowed with them.
\end{itemize}

We rejected this option.

\paragraph{Using \tcode{T\&\&} as the default}

This avoids a copy when doing \tcode{auto object = *it} (where it is a \tcode{std::generator::iterator}),
but it is easy to misuse, consider:

\begin{colorblock}
auto f = [] -> std::generator<std::string> { co_yield "footgun"; }();
for (auto&& x : f | std::views::filter([](std::string s) { return s.size() > 0; })) {
    std::cout << x << '\n'; // outputs a single empty line
}
\end{colorblock}

We rejected this option.
\begin{note}
Nevertheless, we came back to this option
after much discussion of pros and cons
in both LEWG and several additional meetings
if a Coroutine Task Force formed by LEWG Chair
specifically to build consensus.
\end{note}

\paragraph{Doing something clever for move-only types}

We considered returning \tcode{T\&} for move_only types so that they can be moved from by default.
We realized this was too clever and inconsistent.
Notably, adding a copy constructor to \tcode{T} would change the meaning of the code.

We rejected this option.

\paragraph{Doing something clever for reference types}

By default \tcode{generator<reference_wrapper<T>>} could yield \tcode{reference_wrapper<T>} has that is already a "reference-like" type.
However, no other view does that, "reference-like" is fuzzily defined, and this would probably cause more trouble than it's worth.

We rejected this option.

\paragraph{Keeping the D2168R4 design}

Returning values has the potential to severely impact performance, is inconsistent with other views, and is not necessary.
It also did not work with move-only types.

The change, along with an implementation strategy described in the "How to store the yielded value in the promise type?" guarantees that
no copy needs to be made if the reference and yielded types are the same (with qualifiers stripped).

We think this new approach keeps the simplicity of the original design, improves performance, and works with more types.

Thank you LEWG, and in particular Mathias, for highlighting these concerns!

\subsection{Separately specifyable Value Type}

This proposal supports specifying both the "yielded" type, which is the iterator's reference type (not required to be a reference) and its corresponding value type.
This allow ranges to handle proxy types and wrapped \tcode{reference}, like this implementation of \tcode{zip}:

\begin{colorblock}
namespace ranges = std::ranges;

template<ranges::input_range Rng1, ranges::input_range Rng2>
std::generator<
    std::tuple<ranges::range_reference_t<Rng1>, ranges::range_reference_t<Rng2>>
    std::tuple<ranges::range_value_t<Rng1>, ranges::range_value_t<Rng2>>>
zip(Rng1 r1, Rng2 r2) {
    auto it1 = ranges::begin(r1);
    auto it2 = ranges::begin(r2);
    auto end1 = ranges::end(r1);
    auto end2 = ranges::end(r2);
    for (; it1 != end1 && it2 != end2; ++it1, ++it2) {
        co_yield {*it1, *it2};
    }
}
\end{colorblock}

In this second example, using \tcode{string} as value type ensures that calling code can take the necessary steps
to make sure iterating over a generator would not invalidate any of the yielded values.

\begin{colorblock}
// Yielding string literals : always fine
std::generator<std::string_view, std::string_view> string_views() {
    co_yield "foo";
    co_yield "bar";
}

std::generator<std::string_view, std::string> strings() {
    co_yield "start";
    std::string s;
    for (auto sv : string_views()) {
        s = sv;
        s.push_back('!');
        co_yield s;
    }
    co_yield "end";
}

// conversion to a vector of strings
// If the value_type was string_view, it would convert to a vector of string_view,
// which would lead to undefined behavior operating on elements of v that were
// invalidated while iterating through the generator.
auto v = std::ranges::to<vector>(strings()); // (@{\paper{P1206R3}}@)
\end{colorblock}


\subsection{How to store the yielded value in the promise type?}

There are multiple implementation strategies possible to store the value in the generator.
An early revision of this paper always stored a copy of the yielded value, leading to an extra copy.
Later revisions supported storing the yielded value in an awaitable object
returned from the promise's \tcode{yield_value} function.

However, the object denoted by a glvalue yield expression is guaranteed
to live until the coroutine resumes.
We can take advantage of that fact by
storing only a pointer to the denoted object in the promise,
if the result of dereferencing that pointer is convertible to the generator's
reference type. We guarantee this is the case by providing a \tcode{yield_value}
whose parameter type is always a reference type
(\tcode{conditional_t<is_reference_v<Reference>, Reference, const Reference\&>}).
This forces any conversions to happen inside the coroutine itself,
yielding a temporary glvalue that can later be dereferenced
to an lvalue which is trivially \tcode{static_cast}ed to \tcode{Reference}
in the iterator's \tcode{operator*}.

A drawback of this solution is that the yielded value is only destroyed at the end of the
full expression in which \tcode{co_yield} appears, so given
\begin{colorblock}
    (co_yield x, co_yield y); // x is destroyed after y is yielded.
\end{colorblock}
We think this is a reasonable tradeoff given that this approach minimizes the
number of copies must be made of the yielded value.
We force the coroutine to materialize the element to be yielded,
but after doing so can cleanly pass a reference to that element through
the coroutine and iterator machinery and directly to consuming code.


\subsection{Recursive generator}

A "recursive generator" is a coroutine that supports the ability to directly \tcode{co_yield}
a generator of the same type as a way of emitting the elements of that \tcode{generator}
as elements of the current \tcode{generator}.

Example: A \tcode{generator} can \tcode{co_yield} other generators of the same type
\begin{colorblock}
    std::generator<const std::string&> delete_rows(std::string table, std::vector<int> ids) {
        for (int id : ids) {
            co_yield std::format("DELETE FROM {0} WHERE id = {1};", table, id);
        }
    }

    std::generator<const std::string&> all_queries() {
        co_yield std::ranges::elements_of(delete_rows("user", {4, 7, 9 10}));
        co_yield std::ranges::elements_of(delete_rows("order", {11, 19}));
    }
\end{colorblock}

Example: A \tcode{generator} can also be used recursively
\begin{colorblock}
    using namespace std;

    struct Tree {
        Tree* left;
        Tree* right;
        int value;
    };

    generator<int> visit(Tree& tree) {
        if (tree.left) co_yield ranges::elements_of(visit(*tree.left));
        co_yield tree.value;
        if (tree.right) co_yield ranges::elements_of(visit(*tree.right));
    }
\end{colorblock}

In addition to being more concise, the ability to directly yield a nested generator has some
performance benefits compared to iterating over the contents of the nested generator and
manually yielding each of its elements.

Yielding a nested \tcode{generator} allows the consumer of the top-level coroutine to
directly resume the current leaf generator when incrementing the iterator, whereas a solution that has each generator manually iterating over elements of the child generator
requires O(depth) coroutine resumptions/suspensions per element of the sequence.

Example: Non-recursive form incurs O(depth) resumptions/suspensions per element
and is more cumbersome to write:
\begin{colorblock}
    using namespace std;

    generator<int> slow_visit(Tree& tree) {
        if (tree.left) {
            for (int x : ranges::elements_of(visit(*tree.left)))
                co_yield x;
        }
        co_yield tree.value;
        if (tree.right) {
            for (int x : ranges::elements_of(visit(*tree.right)))
                co_yield x;
        }
    }
\end{colorblock}

Exceptions that propagate out of the body of nested \tcode{generator} coroutines
are rethrown into the parent coroutine from the \tcode{co_yield} expression rather
than propagating out of the top-level \tcode{iterator::operator++()}.
This follows the mental model that
\tcode{co_yield someGenerator} is semantically equivalent to
manually iterating over the elements and yielding each element.

For example: \tcode{nested_ints()} is semantically equivalent to \tcode{manual_ints()}
\begin{colorblock}
    std::generator<int> might_throw() {
        co_yield 0;
        throw some_error{};
    }

    std::generator<int> nested_ints() {
        try {
            co_yield std::ranges::elements_of(might_throw());
        } catch (const some_error&) {}
        co_yield 1;
    }

    // nested_ints() is semantically equivalent to the following:
    std::generator<int> manual_ints() {
        try {
            for (int x : might_throw()) {
                co_yield x;
            }
        } catch (const some_error&) {}
        co_yield 1;
    }

    void consumer() {
        for (int x : nested_ints()) {
            std::cout << x << " "; // outputs 0 1
        }

        for (int x : manual_ints()) {
            std::cout << x << " "; // also outputs 0 1
        }
    }
\end{colorblock}

\subsection{\tcode{std::ranges::elements_of}}

\tcode{ranges::elements_of} is a utility function that prevents ambiguity when a nested generator type is convertible to the value type
of the present generator

\begin{colorblock}
    generator<int> f()
    {
        co_yield 42;
    }

    generator<any> g()
    {
        co_yield f(); // should we yield 42 or generator<int> ?
    }

\end{colorblock}

To avoid this issue, we propose that:
\begin{itemize}
    \item \tcode{co_yield <expression>} yields the value directly, and
    \item \tcode{co_yield elements_of(<expression>)} yields successive elements from the nested generator.
\end{itemize}

For convenience, we further propose that \tcode{co_yield elements_of(x)} be extended to support
yielding the values of arbitrary ranges beyond generators, ie

\begin{colorblock}
    std::generator<int> f()
    {
        std::vector<int> v = /*... */;
        co_yield std::ranges::elements_of(v);
    }

\end{colorblock}

\subsection{Symmetric transfer}

The recursive form can be implemented efficiently with symmetric transfer.
Earlier works in \cite{CppCoro} implemented this feature in a distinct \tcode{recursive_generator} type.

However, it appears that a single type is reasonably efficient thanks to HALO optimizations and symmetric transfer.
The memory cost of that feature is two extra pointers per generator\footnote{
The two pointers in our implementation have non-overlapping active times;
we believe the pair can be optimized into a single pointer's space
with some bit hacking to store a discriminator in the unused lower bits.}.
It is difficult to evaluate the runtime cost of our design given the current coroutine support in compilers.
However our tests show no noticeable difference between a \tcode{generator} and a \tcode{recursive_generator}
which is called non-recursively. It is worth noting that the proposed design makes sure that HALO \cite{P0981R0} optimizations are possible.

While we think a single \tcode{generator} type is sufficient and offers a better API, there are three options:

\begin{itemize}
    \item A single \tcode{generator} type supporting recursive calls (this proposal).

    \item A separate type \tcode{recursive_generator} that can yield values from either a \tcode{recursive_generator} or a \tcode{generator}. That may offer very negligible performance benefits, same memory usage.

    \item A separate {recursive_generator} type which can only yield values from other \tcode{recursive_generator}s.

    That third option would make the following ill-formed:

    \begin{colorblock}
        generator<int> f();
        recursive_generator<int> g() {
            co_yield f(); // incompatible types
        }
    \end{colorblock}

    Instead you would need to write:
    \begin{colorblock}
        recursive_generator<int> g() {
            for (int x : f()) co_yield x;
        }
    \end{colorblock}

    Such a limitation can make it difficult to decide at the time of writing a generator
    coroutine whether or not you should return a \tcode{generator} or \tcode{recursive_generator}
    as you may not know at the time whether or not this particular generator will be used
    within \tcode{recursive_generator} or not.

    If you choose the \tcode{generator} return-type and then later someone wants to yield its
    elements from a \tcode{recursive_generator} then you either need to manually yield its
    elements one-by-one or use a helper function that adapts the \tcode{generator} into a
    \tcode{recursive_generator}. Both of these options can add runtime cost compared to the case where the generator was originally written to return a \tcode{recursive_generator},
    as it requires two coroutine resumptions per element instead of a single coroutine resumption.

    Because of these limitations, we are not recommending this approach.
\end{itemize}

Symmetric transfer is possible for different generator types as long as the \tcode{reference} type is the same, aka,
different value type or allocator type does not preclude symmetric transfer (see the section on allocators).

\section{Allocator support}

In line with the design exploration done in section 2 of \paper{P1681R0}, \tcode{std::generator} supports both stateless and stateful allocators and strives to minimize the interface verbosity for stateless allocators by templating both the generator itself and the \tcode{promise_type}'s \tcode{new} operator
on the allocator type. Details for this interface are found in \paper{P1681R0}.

\tcode{coroutine_parameter_preview_t} such as discussed in section 3 of \paper{P1681R0} has not been explored in this paper.

\begin{colorblock}
    std::generator<int> stateless_example() {
        co_yield 42;
    }

    template <class Allocator>
    std::generator<int> allocator_example(std::allocator_arg_t, Allocator alloc) {
        co_yield 42;
    }

    my_allocator<std::byte> alloc;
    input_range auto rng = allocator_example(std::allocator_arg, alloc);
\end{colorblock}

The proposed interface requires that, if an allocator is provided, it is the second argument to the coroutine function,
immediately preceded by an argument of type \tcode{std::allocator_arg_t}.
This approach is necessary to distinguish the allocator desired to allocate the coroutine state from allocators whose purpose is to be used in the body of the coroutine function.
The required argument order might be a limitation if any other argument is required to be the first. However, we cannot think of any scenario where that would be the case.

We think it is important that all standard and user coroutine types can accommodate similar interfaces for allocator support.
In fact, the implementation for that allocator support can be shared amongst \tcode{generator}, \tcode{lazy}, and other standard types.

\textbf{By default \tcode{std::generator} type erases the allocator type, and uses \tcode{std::allocator} unless an allocator is provided to
the coroutine function}.
Then:

\textbf{Type erased allocator(default)}

\begin{colorblock}
template <class Allocator>
std::generator<int> f(std::allocator_arg_t, Allocator alloc) {}

f(std::allocator_arg, my_alloc{});
\end{colorblock}

Returns a generator of type \tcode{std::generator<int, void, void>}
where the final \tcode{void} denotes that the allocator is type erased.
The allocator is stored in the same allocation as the coroutine state
if it is stateful or not default constructible; a pointer is always stored so that
the \tcode{deallocate} method of the type erased allocator can be called.

\textbf{No allocator}

\begin{colorblock}
std::generator<int> f() {}
f();
\end{colorblock}

Again, returns a generator of type \tcode{std::generator<int, void, void>}
where the final \tcode{void} denotes that the allocator is type erased.
A pointer is stored so that
the \tcode{deallocate} method
of the type-erased allocator can be called,
but the default allocator (\tcode{std::allocator})
need not be stored since it is stateless.

\textbf{Explicit stateless allocator}

\begin{colorblock}
std::generator<int, void, std::stateless_allocator<int>> f() {}
f();
\end{colorblock}

No extra storage is used for the allocator because it is stateless.

\textbf{Explicit stateful allocator}

\begin{colorblock}
std::generator<int, void, some_stateful_allocator<int>>
    f(std::allocator_arg_t, some_stateful_allocator<int> alloc) {}
f(std::allocator_arg, some_allocator); // must be convertible to some_stateful_allocator
\end{colorblock}

The allocator is copied in the coroutine state.

\subsection{Can we postpone adding allocator support?}

A case can be made that allocator support could be added to \tcode{std::generator} later.
However, because the proposed design has the allocator as a template parameter,
adding allocator after \tcode{std::generator} ships would represent an ABI break.
We recommend that we add allocator support as proposed in this paper now and make sure that the design remains consistent as work on \tcode{std::lazy}
is made in this cycle.
However, it would be possible to extend support for different mechanisms (such as presented in section 3 of \paper{P1681R0} later.


\subsection{Interaction of symmetric transfer and allocator support}

The allocator must necessarily be part of a coroutine's promise type
since implementations query the promise for allocation functions.
Nonetheless, it would seem silly for a generator to be unable to nest another
generator with identical element type but differing allocator.
For that matter, even differing value types shouldn't be problematic:
the only interface between the generator and the coroutine it wraps
that differs depending on the type arguments to \tcode{generator}
is \tcode{yield_value}.
Ideally, generators would be able to recurse into other generators
whose \tcode{yield_value} has the same parameter type
even if all three template arguments to \tcode{generator} differ.

Our implementation uses a base class
to implement the non-allocation behaviors
for \tcode{genera\-tor}'s promise type
so that generators with different allocator types
can yield each other.
Doing so, however, requires that we partially erase
the type of a \tcode{coroutine_handle} so we can resume it later
knowing only that its promise type derives from a particular base.

There are at least two ways to implement this partial type erasure:
\begin{itemize}
\item Storing a pointer in the common base to
  a component with full type knowledge, which can then
  resume the targeted coroutine,
\item Relax the preconditions on some of the \tcode{coroutine_handle} functions
  to allow conversion from
  \tcode{coroutine_handle<void>} to \tcode{coroutine_handle<T>} when
  the source's corresponding \tcode{address()} value was obtained from
  a \tcode{coroutine_handle} referring to a coroutine whose promise object
  is pointer-interconvertible with an object of type \tcode{T}.
\end{itemize}

Our current plan is to standardize
the intent to allow yielding nested generators
with different allocator and value types,
leaving the details of the implementation unspecified,
and to later separately propose the changes to \tcode{coroutine_handle}
that enable that implementation to be maximally efficient.


\section{Implementation and experience}

\tcode{generator} has been provided as part of cppcoro and folly.
However, cppcoro offers a separate \tcode{recursive_generator} type, which is different than the proposed design.

Folly uses a single \tcode{generator} type, which can be recursive but doesn't implement symmetric transfer. Despite that,
Folly users found the use of \tcode{Folly:::Generator} to be a lot more efficient than the eager algorithm they replaced with it.

\tcode{ranges-v3} also implements a \tcode{generator} type, which is never recursive and predates the work on move-only views and
iterators \cite{P1456R1}, \cite{P1207R0} which forces this implementation to ref-count the coroutine handler.

Our implementation \cite{Implementation} consists of a single type that takes advantage of symmetric transfer to implement
recursion - it notably works well with three different major standard libraries.

\section{Performance \& benchmarks}

\begin{note}
These benchmark results are fairly dated now - roughly a year old - and should be taken with a grain of salt.
\end{note}

Because implementations are still being perfected, and because performance is extremely dependant on whether HALO optimization (see \paper{P0981R0})
occurs, it is difficult at this time to make definitive statements about the performance of the proposed design.

At the time of the writing of this paper, Clang is able to inline non-nested coroutines whether the implementation
supports nested coroutines or not, while GCC never performs HALO optimization.

When the coroutine is not inlined, support for recursion does not noticeably impact performance.
And, when the coroutine yields another generator, the performance of the recursive version is noticeably faster than
yielding each element of the range. This is especially noticeable with deep recursion.

\begin{adjustbox}{center}
\texttt{
\begin{threeparttable}
\begin{tabular}{|l?r|r?r|r?r|r|}
    \hline
    & Clang & Clang ST\tnote{1} & GCC & GCC ST\tnote{1} & MSVC & MSVC ST\tnote{1} \\
    \hline
    Single value & (1) 0.235 &  (2) 2.36 & 12.4 & 13.4 & 61.9 & 63.7 \\
    \hline
    Single value, noinline (3) & 13.5  & 13.7 & 14.1 & 15.2 & 63.8 & 64.4\\
    \hline
    Deep nesting & 43670266.0 & (4) 427955.0 & 58801348 & 338736 & 224052033 & 4760914\\
    \hline
\end{tabular}
\begin{tablenotes}
\item[1] Symmetric transfer.
\end{tablenotes}
\end{threeparttable}
}
\end{adjustbox}


The values are expressed in nanoseconds. However, please note that the comparison of the same result across compiler is not meaningful, notably because the MSVC results were obtained on different hardware.
That being said, we observe:

\begin{itemize}
    \item Only Clang can perform constant folding of values yielded by simple coroutine (1)
    \item When the \tcode{generator} supports symmetric transfer, clang is not able to fully inline the generator construction, but HALO is still performed (2).
    \item When HALO is not performed, the relative performance of both approaches is similar (3).
    \item Supporting recursion is greatly beneficial to nested/recursive algorithms (4).
\end{itemize}

The code for these benchmarks, as well as more detailed results, can be found on \href{https://github.com/cor3ntin/coro_benchmark}{Github}.

\newpage
\section{Wording}

\ednote{Wording is relative to Working Draft N4910 \cite{N4910}. \\
Insert in lexicographical order in [version.syn]
(updating \tcode{YYYYXXL} to the date of merge):}

\begin{addedblock}
\begin{codeblock}
#define __cpp_lib_generator                       YYYYXXL // also in <generator>
\end{codeblock}
\end{addedblock}

\ednote{Modify [ranges.general] as follows:}

\rSec2[ranges.general]{General}
This Clause describes components for dealing with ranges of elements.

The following subclauses describe range and view requirements, and
components for range primitives \added{and range generators}
as summarized in Table [tab:range.summary].

\ednote{Add a new row at the end of [tab:range.summary] ``Range generators''
with header \tcode{<generator>} referring to
the new subclause [coroutine.generator] added below.}

\ednote{Add the declaration of \tcode{ranges::elements_of}
to the \tcode{<ranges>} synopsis:}

\rSec2[ranges.syn]{Header \tcode{<ranges>} synopsis}

\begin{codeblock}
namespace std::ranges {
[...]

  template<@\libconcept{input_or_output_iterator}@ I, @\libconcept{sentinel_for}@<I> S, subrange_kind K>
  inline constexpr bool enable_borrowed_range<subrange<I, S, K>> = true;

  // [range.dangling], dangling iterator handling
  struct dangling;

\end{codeblock}
\begin{addedblock}
\begin{codeblock}
  // [elementsof.overview], class template elements_of
  template<range R, class Allocator = allocator<byte>>
  struct elements_of;
\end{codeblock}
\end{addedblock}
\begin{codeblock}
  template<@\libconcept{range}@ R>
  using borrowed_iterator_t = conditional_t<@\libconcept{borrowed_range}@<R>, iterator_t<R>, dangling>;

  [...]
}
\end{codeblock}

\ednote{Insert the following new subclause immediately after [range.dangling]:}

\begin{addedblock}

\rSec2[ranges.elementsof]{class template \tcode{elements_of}}

Specializations of \tcode{elements_of} encapsulate a range and
act as a tag in overload sets to disambiguate
when a range should be treated as a sequence
rather than a single value.

\begin{example}
    \begin{codeblock}
        template <bool YieldElements>
        std::generator<any> f(std::ranges::input_range auto&& rng) {
            if constexpr (YieldElements)
                co_yield std::ranges::elements_of(rng); // yield each element of rng
            else
                co_yield rng; // yield rng as a single value
        }
    \end{codeblock}
\end{example}

\begin{codeblock}
namespace std::ranges {
  template<range R, class Allocator = allocator<byte>>
  struct elements_of {
    [[no_unique_address]] R range;
    [[no_unique_address]] Allocator allocator{};
  };

  template<class R, class Allocator = allocator<byte>>
  elements_of(R&&, Allocator = {}) -> elements_of<R&&, Allocator>;
}
\end{codeblock}

\end{addedblock}

\ednote{Add the following subclause to the end of [ranges]:}

\begin{addedblock}
\rSec2[coroutine.generator]{Range Generators}

\rSec3[coroutine.generator.overview]{Overview}
\tcode{generator} presents a view of the elements yielded
by the evaluation of a coroutine.

A \tcode{generator} generates a sequence of elements by
repeatedly resuming the coroutine from which it was returned.
Elements of the sequence are produced by the coroutine
each time a \tcode{co_yield} statement is evaluated.
When the \tcode{co_yield} statement is of the form
\tcode{co_yield elements_of(rng)},
each element of the range \tcode{rng}
is successively produced
as an element of the sequence.

\begin{example}
    \begin{codeblock}
        std::generator<int> ints(int start = 0) {
            while (true)
                co_yield start++;
        }

        void f() {
            for (auto i : ints() | std::views::take(3))
                std::cout << i << ' '; // prints 0 1 2
        }
    \end{codeblock}
\end{example}

\rSec3[generator.syn]{Header \tcode{<generator>} synopsis}

\begin{codeblock}
namespace std {
  // [coroutine.generator.class], class template \tcode{generator}
  template<class Ref, class V = void, class Allocator = void>
  class generator;

  template<class Ref, class V, class Allocator>
  constexpr bool ranges::enable_view<generator<Ref, V, Allocator>> = true;
}
\end{codeblock}

\rSec3[coroutine.generator.class]{Class template \tcode{generator}}

\begin{codeblock}
namespace std {
  template<class Ref, class V = void, class Allocator = void>
  class generator {
  private:
    using @\exposid{value}@ =       // \expos
      conditional_t<is_void_v<V>, remove_cvref_t<Ref>, V>;
    using @\exposid{reference}@ =   // \expos
      conditional_t<is_void_v<V>, Ref&&, Ref>;
    class @\exposid{iterator}@;     // \expos

    coroutine_handle<promise_type> @\exposid{coroutine_}@ = nullptr; // \expos

  public:
    using yielded =
      conditional_t<is_reference_v<@\exposid{reference}@>, @\exposid{reference}@, const @\exposid{reference}@&>;

    class promise_type;

    generator(const generator&) = delete;
    generator(generator&& other) noexcept;

    ~generator();

    generator& operator=(generator other) noexcept;

    @\exposid{iterator}@ begin();
    default_sentinel_t end() const noexcept;
  };
}
\end{codeblock}

\mandates
\begin{itemize}
\item \exposid{value} is a cv-unqualified object type.

\item \exposid{reference} is either a reference type, or
a cv-unqualified object type that models \libconcept{copy_constructible}.

\item Let \tcode{RRef} denote \tcode{remove_reference_t<\exposid{reference}>\&\&}
if \exposid{reference} is a reference type,
or \exposid{reference} otherwise.
Each of:
\begin{itemize}
\item \tcode{common_reference_with<\exposid{reference}\&\&, \exposid{value}\&>},
\item \tcode{common_reference_with<\exposid{reference}\&\&, RRef\&\&>}, and
\item \tcode{common_reference_with<RRef\&\&, const \exposid{value}\&>}
\end{itemize}
is modeled.
\begin{note}
These requirements ensure the exposition-only \exposid{iterator} type
can model \tcode{indirectly_readable} and thus \tcode{input_iterator}.
\end{note}
\end{itemize}

\preconditions
\tcode{Allocator} is \tcode{void} or
meets the \tcode{Cpp17Allocator} requirements.

Specializations of \tcode{generator} model \tcode{view} and \tcode{input_range}.

The behavior of a program that adds a specialization
for \tcode{generator} is undefined.

A \tcode{generator} object has
an associated stack of coroutine handles,
which is initially empty.

A coroutine handle is associated with
at most one \tcode{generator} object at a time.

\rSec3[generator.members]{Members}

\begin{itemdecl}
generator(generator&& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
Initializes \tcode{\exposid{coroutine_}} with \tcode{exchange(other.\exposid{coroutine_}, \{\})}.
\end{itemdescr}

\begin{itemdecl}
~generator();
\end{itemdecl}

\begin{itemdescr}
\effects
Equivalent to:
\begin{codeblock}
    if (@\exposid{coroutine_}@) {
      @\exposid{coroutine_}@.destroy();
    }
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
generator& operator=(generator that) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects
Equivalent to:
\tcode{swap(\exposid{coroutine_}, that.\exposid{coroutine_})}.

\returns
\tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
@\exposid{iterator}@ begin();
\end{itemdecl}

\begin{itemdescr}
\expects
\tcode{\exposid{coroutine_}} refers to a coroutine
suspended at its initial suspend point ([dcl.fct.def.coroutine]).

\effects
Equivalent to: \tcode{\exposid{coroutine_}.resume()}.

\returns
An \tcode{\exposid{iterator}} object
whose member \tcode{\exposid{coroutine_}}
refers to the same coroutine as does
\tcode{\exposid{coroutine_}}.

\remarks
This function pushes \exposid{coroutine_}
onto the \tcode{generator}'s stack
of associated coroutine handles.

\begin{note}
    A program that calls \tcode{begin}
    more than once on the same generator
    has undefined behavior.
\end{note}
\end{itemdescr}

\begin{itemdecl}
default_sentinel_t end() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\returns
\tcode{default_sentinel}.
\end{itemdescr}


\rSec3[coroutine.generator.promise]{class \tcode{generator::promise_type}}

\begin{codeblock}
namespace std::ranges {
  template<class Ref, class V, class Allocator>
  class generator<Ref, V, Allocator>::promise_type {
  public:
    generator get_return_object() noexcept;

    suspend_always initial_suspend() noexcept;
    auto final_suspend() noexcept;

    suspend_always yield_value(yielded value) noexcept;

    auto yield_value(const remove_reference_t<yielded>& lvalue)
      requires is_rvalue_reference_v<yielded> &&
        constructible_from<remove_cvref_t<yielded>, const remove_reference_t<yielded>&>;

    template<class R2, class V2, class Alloc2, class Unused>
      requires same_as<typename generator<T2, V2, Alloc2>::yielded, yielded>
        auto yield_value(ranges::elements_of<generator<T2, V2, Alloc2>&&, Unused> g) noexcept;

    template<ranges::input_range Rng, class Alloc>
      requires convertible_to<ranges::range_reference_t<Rng>, yielded>
        auto yield_value(ranges::elements_of<Rng, Alloc> r) noexcept;

    void await_transform() = delete;

    void return_void() noexcept {}

    void unhandled_exception();

    void* operator new(size_t size)
      requires same_as<Allocator, void> || default_initializable<Allocator>;

    template<class Alloc, class... Args>
      requires same_as<Allocator, void> || convertible_to<Alloc, Allocator>
        void* operator new(size_t size, allocator_arg_t, Alloc&& alloc, Args&...);

    template<class This, class Alloc, class... Args>
      requires same_as<Allocator, void> || convertible_to<Alloc, Allocator>
        void* operator new(size_t size, This&, allocator_arg_t, Alloc&& alloc, Args&...);

    void operator delete(void* pointer, size_t size) noexcept;

  private:
    add_pointer_t<yielded> @\exposid{value_}@ = nullptr; // \expos
    exception_ptr @\exposid{except_}@; // \expos
  };
}
\end{codeblock}

\begin{itemdecl}
generator get_return_object() noexcept;
\end{itemdecl}

\begin{itemdescr}
\returns
A \tcode{generator} object whose member \tcode{\exposid{coroutine_}}
is \tcode{coroutine_handle<promise_type>::from_promise(*this)}.
\end{itemdescr}

\begin{itemdecl}
suspend_always initial_suspend() noexcept;
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{\{\}}.
\end{itemdescr}

\begin{itemdecl}
auto final_suspend() noexcept;
\end{itemdecl}

\begin{itemdescr}
\expects
A handle for the coroutine whose promise object is \tcode{*this}
is at the top of the stack of associated coroutine handles
of some \tcode{generator} object \tcode{x}.
This function is called by that coroutine
upon reaching its final suspend point~([dcl.fct.def.coroutine]).

\returns
An awaitable object of unspecified type
whose member functions arrange for the
calling coroutine to be suspended,
pop the coroutine handle
from the top of \tcode{x}'s stack of associated coroutine handles,
and resume execution of the coroutine referred to by
the new top-of-stack coroutine handle, if any.
If the stack is empty after popping,
control flow returns to the
current coroutine caller or resumer~([dcl.fct.def.coroutine]).
\end{itemdescr}

\begin{itemdecl}
suspend_always yield_value(yielded x) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects
Equivalent to:
\tcode{\exposid{value_} = addressof(x)}.

\returns
\tcode{\{\}}.
\end{itemdescr}

\begin{itemdecl}
auto yield_value(const remove_reference_t<yielded>& lvalue)
  requires is_rvalue_reference_v<yielded> &&
    constructible_from<remove_cvref_t<yielded>, const remove_reference_t<yielded>&>;
\end{itemdecl}

\begin{itemdescr}
\expects
A handle for the coroutine whose promise object is \tcode{*this}
is at the top of the stack of associated coroutine handles
of some \tcode{generator} object \tcode{x}.

\returns
An awaitable object of an unspecified type~([expr.await])
that stores an object of type \tcode{remove_cvref_t<yielded>}
direct-non-list-initialized with \tcode{lvalue},
whose member functions arrange for
\tcode{\exposid{value_}} to point to that stored object
and then suspend the coroutine.

\throws
Any exception thrown by the initialization of the stored object.

\remarks
A \grammarterm{yield-expression} that calls this function
has type \tcode{void}~([expr.yield]).
\end{itemdescr}

\begin{itemdecl}
template<class T2, class V2, class Alloc2, class Unused>
  requires same_as<typename generator<T2, V2, Alloc2>::yielded, yielded>
    auto yield_value(ranges::elements_of<generator<T2, V2, Alloc2>&&, Unused> g) noexcept;
\end{itemdecl}

\begin{itemdescr}
\expects
A handle for the coroutine whose promise object is \tcode{*this}
is at the top of the stack of associated coroutine handles
of some \tcode{generator} object \tcode{x}.

\returns
An awaitable object of an unspecified type~([expr.await])
which takes ownership of the generator \tcode{g.range},
whose member \tcode{await_suspend}
pushes \tcode{g.range.\exposid{coroutine_}} atop the stack of
coroutine handles associated with \tcode{x}
and resumes execution of the coroutine referred to
by \tcode{g.range.\exposid{coroutine_}}, and
whose member \tcode{await_resume} evaluates
\tcode{rethrow_exception(\exposid{except_})}
if \tcode{bool(\exposid{except_})} is \tcode{true}.
If \tcode{bool(\exposid{except_})} is \tcode{false},
the \tcode{await_resume} member has no effects.

\remarks
A \grammarterm{yield-expression} that calls this function
has type \tcode{void}~([expr.yield]).
\end{itemdescr}

\begin{itemdecl}
template<ranges::input_range Rng, class Alloc>
  requires convertible_to<ranges::range_reference_t<Rng>, yielded>
    auto yield_value(ranges::elements_of<Rng, Alloc> r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects
Equivalent to:
\begin{codeblock}
    auto nested = [](allocator_arg_t, Alloc, auto* range_ptr)
      -> generator<yielded, ranges::range_value_t<Rng>, Alloc> {
        using RRef = ranges::range_reference_t<Rng>;
        for (RRef&& e : *range_ptr)
          co_yield static_cast<yielded>(std::forward<RRef>(e));
      };
    return yield_value(ranges::elements_of(nested(
      allocator_arg, r.allocator, addressof(r.range))));
\end{codeblock}

\remarks
A \grammarterm{yield-expression} that calls this function
has type \tcode{void}~([expr.yield]).
\end{itemdescr}

\begin{itemdecl}
void unhandled_exception();
\end{itemdecl}

\begin{itemdescr}
\expects
A handle for the coroutine whose promise object is \tcode{*this}
is at the top of the stack of associated coroutine handles
of some \tcode{generator} object \tcode{x}.

\effects
If the handle for the coroutine
whose promise object is \tcode{*this}
is the sole element of \tcode{x}'s stack of associated coroutines,
equivalent to: \tcode{throw;}
Otherwise, assigns \tcode{current_exception()} to \tcode{\exposid{except_}}.
\end{itemdescr}

\begin{itemdecl}
void* operator new(size_t size)
  requires same_as<Allocator, void> || default_initializable<Allocator>;

template<class Alloc, class... Args>
  requires same_as<Allocator, void> || convertible_to<Alloc, Allocator>
    void* operator new(size_t size, allocator_arg_t, Alloc&& alloc, Args&...);

template<class This, class Alloc, class... Args>
  requires same_as<Allocator, void> || convertible_to<Alloc, Allocator>
    void* operator new(size_t size, This&, allocator_arg_t, Alloc&& alloc, Args&...);
\end{itemdecl}

\begin{itemdescr}
Let \tcode{A} be
\begin{itemize}
\item \tcode{Allocator}, if it is not \tcode{void},
\item \tcode{remove_cvref_t<Alloc>} for the overloads
  with a template parameter \tcode{Alloc}, or
\item \tcode{allocator<void>} otherwise.
\end{itemize}
Let \tcode{B} be \tcode{allocator_traits<A>::template rebind_alloc<U>}
where \tcode{U} is an unspecified type whose size and alignment
are both \tcode{__STDCPP_DEFAULT_NEW_ALIGNMENT__}.

\effects
Initializes an allocator \tcode{b} of type \tcode{B}
with \tcode{A(std::forward<Alloc>(alloc))},
for the overloads with a function parameter \tcode{alloc},
or with \tcode{A()} otherwise.
Uses \tcode{b} to allocate storage for the smallest array
of \tcode{U} sufficient to provide storage for:
\begin{itemize}
\item a coroutine state of size \tcode{size},
\item if \tcode{allocator_traits<B>::is_always_equal::value} is \tcode{false},
space to store a copy of \tcode{b}, and
\item if \tcode{Allocator} is \tcode{void},
unspecified additional state necessary to ensure that
\tcode{operator delete} can later deallocate this memory block
with an allocator equal to \tcode{b}.
\end{itemize}

\returns
A pointer to the allocated storage.
\end{itemdescr}

\begin{itemdecl}
void operator delete(void* pointer, size_t size) noexcept;
\end{itemdecl}

\begin{itemdescr}
\expects
\tcode{pointer} was returned from an invocation of
one of the above overloads of \tcode{operator new}
with a \tcode{size} argument equal to \tcode{size}.

\effects
Deallocates the storage pointed to by \tcode{pointer}
using an allocator equivalent to that used to allocate it.
\end{itemdescr}

\rSec3[coroutine.generator.iterator]{Class template \tcode{generator::\exposid{iterator}}}

\begin{codeblock}
namespace std::ranges {
  template<class Ref, class V, class Allocator>
  class generator<Ref, V, Allocator>::@\exposid{iterator}@ {
  public:
      using value_type = @\exposid{value}@;
      using difference_type = ptrdiff_t;

      @\exposid{iterator}@(@\exposid{iterator}@&& other) noexcept;

      @\exposid{iterator}@& operator=(@\exposid{iterator}@&& other) noexcept;

      @\exposid{reference}@ operator*() const noexcept(is_nothrow_copy_constructible_v<@\exposid{reference}@>);

      @\exposid{iterator}@& operator++();
      void operator++(int);

      friend bool operator==(@\exposid{iterator}@ i, default_sentinel_t) noexcept;

  private:
      coroutine_handle<promise_type> @\exposid{coroutine_}@; // \expos
  };
}
\end{codeblock}

\begin{itemdecl}
@\exposid{iterator}@(@\exposid{iterator}@&& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects
Initializes \tcode{\exposid{coroutine_}}
with \tcode{exchange(other.\exposid{coroutine_}, \{\})}.
\end{itemdescr}

\begin{itemdecl}
@\exposid{iterator}@& operator=(@\exposid{iterator}@&& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects
Equivalent to:
\tcode{\exposid{coroutine_} = exchange(other.\exposid{coroutine_}, \{\});}
\end{itemdescr}

\begin{itemdecl}
@\exposid{reference}@ operator*() const noexcept(is_nothrow_copy_constructible_v<@\exposid{reference}@>);
\end{itemdecl}

\begin{itemdescr}
\expects
\tcode{\exposid{coroutine_}.done()} is \tcode{false}, and
\exposid{coroutine_} is in the stack of coroutine handles associated with
some \tcode{generator}.

Let \tcode{p} be the promise object of the coroutine
referred to by the handle at the top of
the stack of coroutine handles associated with
the \tcode{generator} whose stack includes \exposid{coroutine_}.

\effects
Equivalent to:
\begin{codeblock}
    return static_cast<@\exposid{reference}@>(*p.@\exposid{value_}@);
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
@\exposid{iterator}@& operator++();
\end{itemdecl}

\begin{itemdescr}
\expects
\tcode{\exposid{coroutine_}.done()} is \tcode{false}, and
\exposid{coroutine_} is in the stack of coroutine handles associated with
some \tcode{generator}.

\effects
Resumes the coroutine referred to by the handle
at the top of the stack of coroutine handles associated with
the \tcode{generator} whose stack includes \exposid{coroutine_}.

\returns
\tcode{return *this};
\end{itemdescr}

\begin{itemdecl}
void operator++(int);
\end{itemdecl}

\begin{itemdescr}
\effects
Equivalent to: \tcode{++*this}.
\end{itemdescr}

\begin{itemdecl}
friend bool operator==(@\exposid{iterator}@ i, default_sentinel_t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects
Equivalent to: \tcode{return i.\exposid{coroutine_}.done();}
\end{itemdescr}
\end{addedblock}

\newpage
\section{References}
\renewcommand{\section}[2]{}%
\bibliographystyle{plain}
\bibliography{wg21}

\begin{thebibliography}{9}
    \bibitem[CppCoro]{CppCoro}
    Lewis Baker.
    CppCoro: A library of C++ coroutine abstractions for the coroutines TS.
    \url{https://github.com/lewissbaker/cppcoro}

    \bibitem[Folly]{Folly}
    Facebook.
    Folly: An open-source C++ library developed and used at Facebook.
    \url{https://github.com/facebook/folly}

    \bibitem[range]{range-v3}
    Eric Niebler.
    range-v3 Range library for C++14/17/20.
    \url{https://github.com/ericniebler/range-v3}

    \bibitem[Implementation]{Implementation}
    Casey Carter, Lewis Baker, Corentin Jabot.
    \tcode{std::generator} implementation.
    \url{https://godbolt.org/z/j6rEj3cTb}
\end{thebibliography}

\end{document}
