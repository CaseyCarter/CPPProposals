% !TeX program = luatex
% !TEX encoding = UTF-8

\RequirePackage{luatex85}%
\documentclass{wg21}
\usepackage{threeparttable}
\usepackage{adjustbox}
\usepackage{xcolor,colortbl}
\usepackage{array}
\newcolumntype{?}{!{\vrule width 1pt}}

\title{\tcode{std::generator}: Synchronous Coroutine Generator for Ranges}
\docnumber{D2502R1}
\audience{LEWG}
\author{Casey Carter}{Casey@Carter.net}
%% \authortwo{Lewis Baker}{lewissbaker@gmail.com}
%% \authorthree{Corentin Jabot}{corentin.jabot@gmail.com}

\begin{document}
\maketitle

% TODO:
% * detail "new header" vs. "<ranges>"
% * The "Mathias alternative": generator<meow> should behave
%   like generator<meow&&> instead of like generator<meow const&>
% * LB's concern: "It bothers me that generator<T>, generator<const T>, and
%   generator<const T&> are different types with identical behavior"

\section{Abstract}

We propose a standard library type \tcode{std::generator}
which implements a coroutine generator
that models \tcode{std::ranges::input_range}.

\section{Acknowledgements}

I'd like to thank Lewis Baker and Corentin Jabot,
whose P2168 \cite{P2168R3} I looted shamelessly for this proposal.
This paper is presented as a new revision of
their unpublished D2168R4 for continuity of design.

\section{Revisions}

\subsection{P2502R1}
\begin{itemize}
\item The type \tcode{generator::yielded}
  is now publicly-visible and not exposition-only
  per 2021-12-13 LEWG discussion.
\item Feature-test macro insertion is now
  ordered properly with the other wording.
\item Coroutines for \tcode{generator<T\&\&>} can now yield lvalues;
  the generated element is an xvalue denoting a copy of the lvalue.
\end{itemize}

\subsection{P2502R0}
\begin{itemize}
\item Reorder \tcode{generator}'s template parameters.
  This allows the reference type to be
  more easily defaulted to a true reference,
  while still respecting requests for
  differing value and reference types.
  This preserves the previous design's ease-of-use,
  while providing full generality.
\item Remove concerns about the $\bigoh{1}$ destruction requirement for \tcode{view},
  which has been relaxed by P2415R2 ``What is a view?'' \cite{P2415R2}.
\end{itemize}

\subsection{D2168R4}
\begin{itemize}
\item Wording improvements
\end{itemize}

\subsection{P2168R3}
\begin{itemize}
\item Wording improvements
\end{itemize}

\subsection{P2168R2}
\begin{itemize}
\item Some wording fixes
\item Improve the section on allocator support
\item Updated implementation
\end{itemize}

\subsection{P2168R1}
\begin{itemize}
\item Add benchmarks results and discussion about performance
\item Introduce \tcode{elements_of} to avoid ambiguities when a generator is convertible to the reference type of the parent generator.
\item Add allocator support
\item Symmetric transfer works with generators of different value / allocator types
\item Remove \tcode{\exposid{iterator}::operator->}
\item Put \tcode{generator} in a new \tcode{<generator>} header.
\item Add an other example to motivate the \tcode{Value} template parameter
\end{itemize}


\section{Example}

\begin{colorblock}
    std::generator<int> fib() {
        auto a = 0, b = 1;
        while (true) {
            co_yield std::exchange(a, std::exchange(b, a + b));
        }
    }

    int answer_to_the_universe() {
        auto rng = fib() | std::views::drop(6) | std::views::take(3);
        return std::ranges::fold_left(std::move(range), 0, std::plus{});
    }
\end{colorblock}


\section{Motivation}

C++ 20 had very minimalist library support for coroutines.
Synchronous generators are an important use case for coroutines,
one that cannot be supported
without the machinery presented in this paper.
Writing an efficient recursive generator is non-trivial;
the standard should provide one.


\section{Design}

While the proposed \tcode{std::generator} interface is fairly straightforward, a few decisions are worth pointing out.

\subsection{\tcode{input_view}}

\tcode{std::generator} is a move-only \tcode{view} which models \tcode{input_range} and has move-only iterators.
This is because the coroutine state is a unique resource (even if the coroutine \textit{handle} is copyable).


\subsection{Header}

Multiple options are available as to where to put the \tcode{generator} class.

\begin{itemize}
\item \tcode{<coroutine>}, but \tcode{<coroutine>} is a low level header,
  and \tcode{generator} depends on bits of \tcode{<type_traits>} and \tcode{<iterator>}.

\item \tcode{<ranges>}

\item A new \tcode{<generator>}
\end{itemize}

This paper uses a new \tcode{<generator>} header since P2168R3 did so,
and LEWG has provided no guidance to do otherwise.
We do note on our MSVC STL branch implementation that
\tcode{\#include<ranges>} includes ~52.6k lines of code, and
\tcode{\#include<generator>} ~53.3k lines.
(Note that \tcode{<generator>} is specified to include
both \tcode{<ranges>} and \tcode{<coroutines>}.)
Defining \tcode{generator} in \tcode{<ranges>}
together with a \tcode{\#include<coroutine>}
would penalize people who want \tcode{<ranges>}
but not \tcode{generator} by about 610 LoC.

\section{Reference type}

\tcode{generator} has 3 template parameters: \tcode{generator<T, Allocator = void, U = void>}

From \tcode{T} and \tcode{U}, we derive types:
\begin{codeblock}
using Value = conditional_t<is_void_v<U>, remove_cvref_t<T>, U>;}
using Reference =
  conditional_t<is_void_v<U>,
    conditional_t<is_reference_v<T>, T, const T&>,
    T>;
using Yielded = conditional_t<is_reference_v<Reference>, Reference, const Reference&>;
\end{codeblock}

\begin{itemize}
\item \tcode{Value} is a cv-unqualified object type that specifies the value type
  of the \tcode{generator}'s range and iterators,
\item \tcode{Reference} specifies the reference type
  (not necessarily a core language reference)
  of the \tcode{generator}'s range and iterators, and
\item \tcode{Allocator} is the type of allocator used for the coroutine state,
  which can be \tcode{void} to type-erase
  any allocator specified as a coroutine argument,
  defaulting to \tcode{allocator<byte>} when none is specified.
\item \tcode{Yielded} (necessarily a reference type)
  is the type of the parameter to
  the primary overload of \tcode{yield_value}
  in the generator's associated promise type.
\end{itemize}

\subsection{\tcode{generator<meow>}}
Our expectation is that 98\% of use cases
will need to specify only one parameter.
The resulting generator:
\begin{itemize}
\item has a value type of \tcode{remove_cvref_t<meow>}
\item has a reference type of \tcode{meow}, if it is a reference type, or \tcode{const meow\&}  otherwise,
\item expects \tcode{co_yield} to appear in the body of the generator with operands that are convertible to the reference type, and
\item can use any allocator (via type-erasure)
  defaulting to \tcode{allocator<byte>}.
\end{itemize}

This avoids the performance pitfall from
earlier revisions of the proposal
that used the first argument type directly as reference type;
users who naively chose \tcode{generator<std::string>}
got an iterator that produces independent copies
of the yielded value on every dereference,
when they may have been satisfied by
yielding a reference to the same constant value.

\subsection{\tcode{generator<meow, woof>}}
For the additional 1.5\% of use cases that want
to specify an allocator type statically so they need not constantly pass
pairs of \tcode{allocator_arg, my_allocator} arguments to every coroutine,
we have two-argument tcode{generator}.
The resulting generator:
\begin{itemize}
\item has a value type of \tcode{remove_cvref_t<meow>}
\item has a reference type of \tcode{meow}, if it is a reference type, or \tcode{const meow\&}  otherwise,
\item expects \tcode{co_yield} to appear in the body of the generator with operands that are convertible to the reference type, and
\item can use any allocator convertible to \tcode{woof},
  defaulting to a default-constructed \tcode{woof} if it is \libconcept{default_initializable}.
\end{itemize}

Other than the change in allocation behavior,
two-argument \tcode{generator} is identical to,
and therefore as easy-to-use as,
one-argument \tcode{generator}.

\subsection{\tcode{generator<meow, woof, quack>}}
For the last 0.5\% of people who need \tcode{generator}
to step outside the box and use a proxy reference type,
or who need to generate a range whose iterators yield
prvalues for whatever reason, we have three-argument \tcode{generator}.
The resulting generator:
\begin{itemize}
\item has a value type of \tcode{quack},
\item has a reference type of \tcode{meow},
\item expects \tcode{co_yield} to appear in the body of the generator with operands that are convertible to \tcode{meow}, if it is reference type, and otherwise \tcode{const meow\&}, and
\item can use any allocator (via type-erasure) if \tcode{woof} is \tcode{void},
  or otherwise can use any allocator convertible to \tcode{woof}.
\end{itemize}
Your iterators can yield a prvalue, but
it must be a \libconcept{copy_constructible} type so a copy of
the operand of a single \tcode{co_yield} can be returned multiple times
from repeated dereferences of the same iterator value.

\subsection{Obsolete discussion about reference specification}

\begin{note}
Before P2502R0, \tcode{generator}'s first parameter
\tcode{Type} denoted the reference type of the range / iterators, and
the value type was defaulted to \tcode{remove_cvref_t<Type>}.
The following sections of design discussion from that era
are preserved here.
\end{note}

In earlier versions of this paper,
the reference type was exactly the first template parameter.
This had the advantage of being simple.
But it was a terrible performance trap:

Consider the behavior of the following code assuming the reference type is exactly the first template argument:

\begin{colorblock}
std::generator<std::string> f() {
    std::string hello = "hello";
    co_yield hello;   // 0 or 1 copy depending on implementation
    co_yield "Hello"; // 1 copy (conversion from const char* to std::string)
}

for (auto&& str : f()) {} // 1 copy (*it returns std::string)
\end{colorblock}

Of course the solution, which we advocated for, is for the user to manually specify an explicit reference type:

\begin{colorblock}
    generator<const std::string&> f() {
        std::string hello = "hello";
        co_yield hello;   // 0 or 1 copy depending on implementation
        co_yield "Hello"; // 1 copy (conversion from const char* to std::string)
    }

    for (auto&& str : f()) {} // 0 copy
\end{colorblock}

This works, can be explained, and is even logical. You get what you asked for.
It is nonetheless surprising for non-experts that using the simple \tcode{generator<string>} would create 2 copies per \tcode{co_yield}.

To hope users would not routinely forget
to use a reference type when using \tcode{std::generator}
calls for a heaping barrel of optimism.

We later proposed that for a \tcode{generator<T>},
its reference type be \tcode{conditional_t<is_reference_v<T>, T, const T\&>}.

\newcommand{\cellif}{\cellcolor{red!25}Ill-formed}
\newcommand{\cellid}{\cellcolor{red!70}Ill-formed}
\newcommand{\cellbl}{\cellcolor{green!70}0}
\newcommand{\cellzr}{\cellcolor{green!25}0}
\newcommand{\cellon}{\cellcolor{orange!25}1}


\begin{tabular}{|c|c|c|c|}
\hline
First parameter       & reference type        & default value & can yield mutable lvalue ref? \\ \hline
\tcode{int}           & \tcode{const int\&}   & \tcode{int}   & No                            \\ \hline
\tcode{const int\&}   & \tcode{const int\&}   & \tcode{int}   & No                            \\ \hline
\tcode{int\&}         & \tcode{int\&}         & \tcode{int}   & Yes                           \\ \hline
\tcode{int\&\&}       & \tcode{int\&\&}       & \tcode{int}   & No                            \\ \hline
\tcode{const int\&\&} & \tcode{const int\&\&} & \tcode{int}   & No                            \\ \hline
\end{tabular}

Attempts have been made to characterize the exact relations between reference, value, storage, and \tcode{co_yield} exception types and categories.
Ultimately, a simpler mental model is to characterize what expressions can be yielded for a given reference type and how many copies are made for each scenario.

\begin{tabular}{|c|c|c|c|c|}
\hline
First parameter & \tcode{co_yield const T\&} & \tcode{co_yield T\&} & \tcode{co_yield T\&\&} & \tcode{co_yield U\&\&} \\ \hline
\tcode{T}           & \cellbl & \cellbl & \cellbl & \cellon \\ \hline
\tcode{const T\&}   & \cellzr & \cellzr & \cellzr & \cellon \\ \hline
\tcode{T\&}         & \cellif & \cellzr & \cellif & \cellif \\ \hline
\tcode{T\&\&}       & \cellif & \cellif & \cellzr & \cellon \\ \hline
\tcode{const T\&\&} & \cellif & \cellif & \cellzr & \cellon \\ \hline
\end{tabular}

In this table, we see that only \tcode{co_yield} that requires conversion incurs copy, which is expected.
Coroutines guarantee that the yielded expression exceeds the lifetime of the \tcode{co_yield} expression,
so \tcode{generator} can usefully store
a pointer to the object denoted by a yielded xvalue.

\tcode{co_yield} expressions involving conversion can store the yielded value in an awaiter.
The type of the stored expression is the reference type with its reference qualifiers stripped, but that is an implementation
detail that is not observable and is therefore of limited interest. Of course, that type needs to be constructible from yielded values.

Besides the \tcode{T} case, this behaves very much like returning from a function that is intended.

\subsubsection{Move-only and immovable types}
LEWG was interested in how this works with \tcode{generator} of move-only and immovable types.

\begin{tabular}{|c|c|c|c|}
\hline
First parameter & \tcode{co_yield const T\&} & \tcode{co_yield T\&} & \tcode{co_yield T\&\&} \\ \hline
\tcode{move_only}           & \cellbl & \cellbl & \cellbl \\ \hline
\tcode{const move_only\&}   & \cellzr & \cellzr & \cellzr \\ \hline
\tcode{move_only\&}         & \cellif & \cellzr & \cellif \\ \hline
\tcode{move_only\&\&}       & \cellif & \cellif & \cellzr \\ \hline
\tcode{const move_only\&\&} & \cellif & \cellif & \cellzr \\ \hline \hline

\tcode{immovable}           & \cellbl & \cellbl & \cellbl \\ \hline
\tcode{const immovable\&}   & \cellzr & \cellzr & \cellzr \\ \hline
\tcode{immovable\&}         & \cellif & \cellzr & \cellif \\ \hline
\tcode{immovable\&\&}       & \cellif & \cellif & \cellzr \\ \hline
\tcode{const immovable\&\&} & \cellif & \cellif & \cellzr \\ \hline
\end{tabular}

As that table shows, these types work exactly like other types.
However, to be able to move from a move only reference type, the coroutine has to explicitely state so:

\begin{colorblock}
auto f = []() -> std::generator<move_only> { co_yield move_only{}; }();
for (auto&& x : f) {
    move_only mo = std::move(x); // ill-formed, decltype(x) is const move_only&
}

auto f = []() -> std::generator<move_only&&> { co_yield move_only{}; }();
for (auto&& x : f) {
    move_only mo = x; // ok
}

auto f = []() -> std::generator<move_only&> { move_only m; co_yield m; }();
for (auto&& x : f) {
    move_only mo = std::move(x); // dicey but okay
}
\end{colorblock}

\subsection{Potential downsides}
\begin{colorblock}
auto f = []() -> std::generator<MyType> {
    MyType t;
    co_yield std::move(t);
}();
\end{colorblock}

In the example above \tcode{std::move} doesn't move. Arguably more than usual.
Indeed the code expands to something similar to:

\begin{colorblock}
auto&& __temp = std::move(t);
yield_value(_temp); // <=> promise.value = std::addressof(__temp); // no move
\end{colorblock}

Of course, a move would not have occurred for a \tcode{std::generator<const MyType\&>} either as these things are identical.
It might be suprising?
The only way to avoid that is to create temporary value for rvalue reference, which would force a move to actually occurs,
at the cost of performance.

\subsubsection{Alternatives considered}

\paragraph{Mandating a reference as the first parameter}

We could make \tcode{generator<int>} ill-formed and force people to specify a reference type like \tcode{generator<const int\&>}.
We do not think this is very user-friendly, given that we can provide a reasonable default.

We rejected this option.

\paragraph{Using \tcode{T\&} as the default}

There are two issues with mutable references:
\begin{itemize}
\item They are mutable (They allow mutating the coroutine frame), which would be an \emph{interesting} default.
\item They are very restrictive as to the set of \tcode{co_yield} expression allowed with them.
\end{itemize}

We rejected this option.

\paragraph{Using \tcode{T\&\&} as the default}

This avoids a copy when doing \tcode{auto object = *it} (where it is a \tcode{std::generator::iterator}),
but it is very easy to misuse, consider:

\begin{colorblock}
auto f = []() -> std::generator<std::string> { co_yield "footgun"; }();
for (auto&& x : f) {
    auto y = x; // nothing suggest a move
    y.transform();
    if (x != y) {
        // always triggers, likely to be surprising
    }
}
\end{colorblock}

We rejected this option.

\paragraph{Doing something clever for move-only types}

We considered returning \tcode{T\&} for move_only types so that they can be moved from by default.
We realized this was too clever and inconsistent.
Notably, adding a copy constructor to \tcode{T} would change the meaning of the code.

We rejected this option.

\paragraph{Doing something clever for reference types}

By default \tcode{generator<reference_wrapper<T>>} could yield \tcode{reference_wrapper<T>} has that is already a "reference-like" type.
However, no other view does that, "reference-like" is fuzzily defined, and this would probably cause more trouble than it's worth.

We rejected this option.

\paragraph{Keeping the D2168R4 design}

Returning values has the potential to severely impact performance, is inconsistent with other views, and is not necessary.
It also did not work with move-only types.

The change, along with an implementation strategy described in the "How to store the yielded value in the promise type?" guarantees that
no copy needs to be made if the reference and yielded types are the same (with qualifiers stripped).

We think this new approach keeps the simplicity of the original design, improves performance, and works with more types.

Thank you LEWG, and in particular Mathias, for highlighting these concerns!

\subsection{Separately specifyable Value Type}

This proposal supports specifying both the "yielded" type, which is the iterator's reference type (not required to be a reference) and its corresponding value type.
This allow ranges to handle proxy types and wrapped \tcode{reference}, like this implementation of \tcode{zip}:

\begin{colorblock}
namespace ranges = std::ranges;

template<ranges::input_range Rng1, ranges::input_range Rng2>
std::generator<
    std::tuple<ranges::range_reference_t<Rng1>, ranges::range_reference_t<Rng2>>
    void,
    std::tuple<ranges::range_value_t<Rng1>, ranges::range_value_t<Rng2>>>
zip(Rng1 r1, Rng2 r2) {
    auto it1 = ranges::begin(r1);
    auto it2 = ranges::begin(r2);
    auto end1 = ranges::end(r1);
    auto end2 = ranges::end(r2);
    for (; it1 != end1 && it2 != end2; ++it1, ++it2) {
        co_yield {*it1, *it2};
    }
}
\end{colorblock}

In this second example, using \tcode{string} as value type ensures that calling code can take the necessary steps
to make sure iterating over a generator would not invalidate any of the yielded values.

\begin{colorblock}
// Yielding string literals : always fine
std::generator<std::string_view, void, std::string_view> string_views() {
    co_yield "foo";
    co_yield "bar";
}

std::generator<std::string_view, void, std::string> strings() {
    co_yield "start";
    std::string s;
    for (auto sv : string_views()) {
        s = sv;
        s.push_back('!');
        co_yield s;
    }
    co_yield "end";
}

// conversion to a vector of strings
// If the value_type was string_view, it would convert to a vector of string_view,
// which would lead to undefined behavior operating on elements of v that were
// invalidated while iterating through the generator.
auto v = std::ranges::to<vector>(strings()); // (@{\paper{P1206R3}}@)
\end{colorblock}


\subsection{How to store the yielded value in the promise type?}

There are multiple implementation strategies possible to store the value in the generator.
An early revision of this paper always stored a copy of the yielded value, leading to an extra copy.
Later revisions supported storing the yielded value in an awaitable object
returned from the promise's \tcode{yield_value} function.

However, the object denoted by a glvalue yield expression is guaranteed
to live until the coroutine resumes.
We can take advantage of that fact by storing only a pointer to in the promise,
if the result of dereferencing that pointer is convertible to the generator's
reference type. We guarantee this is the case by providing a \tcode{yield_value}
whose parameter type is
\tcode{conditional_t<is_reference_v<Reference>, Reference, const Reference\&>}.
This forces any conversions to happen inside the coroutine itself,
yielding a temporary glvalue that can later be dereferenced
to an lvalue which is trivially \tcode{static_cast}ed to \tcode{Reference}
in the iterator's \tcode{operator*}.

A drawback of this solution is that the yielded value is only destroyed at the end of the
full expression in which \tcode{co_yield} appears, so given
\begin{colorblock}
    (co_yield x, co_yield y); // x is destroyed after y is yielded.
\end{colorblock}
We think this is a reasonable tradeoff given that this approach minimizes the
number of copies must be made of the yielded value.
We force the coroutine to materialize the element to be yielded,
but after doing so can cleanly pass a reference to that element through
the coroutine and iterator machinery and directly to consuming code.


\subsection{Recursive generator}

A "recursive generator" is a coroutine that supports the ability to directly \tcode{co_yield}
a generator of the same type as a way of emitting the elements of that \tcode{generator}
as elements of the current \tcode{generator}.

Example: A \tcode{generator} can \tcode{co_yield} other generators of the same type
\begin{colorblock}
    std::generator<const std::string&> delete_rows(std::string table, std::vector<int> ids) {
        for (int id : ids) {
            co_yield std::format("DELETE FROM {0} WHERE id = {1};", table, id);
        }
    }

    std::generator<const std::string&> all_queries() {
        co_yield std::ranges::elements_of(delete_rows("user", {4, 7, 9 10}));
        co_yield std::ranges::elements_of(delete_rows("order", {11, 19}));
    }
\end{colorblock}

Example: A \tcode{generator} can also be used recursively
\begin{colorblock}
    using namespace std;

    struct Tree {
        Tree* left;
        Tree* right;
        int value;
    };

    generator<int> visit(Tree& tree) {
        if (tree.left) co_yield ranges::elements_of(visit(*tree.left));
        co_yield tree.value;
        if (tree.right) co_yield ranges::elements_of(visit(*tree.right));
    }
\end{colorblock}

In addition to being more concise, the ability to directly yield a nested generator has some
performance benefits compared to iterating over the contents of the nested generator and
manually yielding each of its elements.

Yielding a nested \tcode{generator} allows the consumer of the top-level coroutine to
directly resume the current leaf generator when incrementing the iterator, whereas a solution that has each generator manually iterating over elements of the child generator
requires O(depth) coroutine resumptions/suspensions per element of the sequence.

Example: Non-recursive form incurs O(depth) resumptions/suspensions per element
and is more cumbersome to write:
\begin{colorblock}
    using namespace std;

    generator<int> slow_visit(Tree& tree) {
        if (tree.left) {
            for (int x : ranges::elements_of(visit(*tree.left)))
                co_yield x;
        }
        co_yield tree.value;
        if (tree.right) {
            for (int x : ranges::elements_of(visit(*tree.right)))
                co_yield x;
        }
    }
\end{colorblock}

Exceptions that propagate out of the body of nested \tcode{generator} coroutines
are rethrown into the parent coroutine from the \tcode{co_yield} expression rather
than propagating out of the top-level \tcode{iterator::operator++()}.
This follows the mental model that
\tcode{co_yield someGenerator} is semantically equivalent to
manually iterating over the elements and yielding each element.

For example: \tcode{nested_ints()} is semantically equivalent to \tcode{manual_ints()}
\begin{colorblock}
    std::generator<int> might_throw() {
        co_yield 0;
        throw some_error{};
    }

    std::generator<int> nested_ints() {
        try {
            co_yield std::ranges::elements_of(might_throw());
        } catch (const some_error&) {}
        co_yield 1;
    }

    // nested_ints() is semantically equivalent to the following:
    std::generator<int> manual_ints() {
        try {
            for (int x : might_throw()) {
                co_yield x;
            }
        } catch (const some_error&) {}
        co_yield 1;
    }

    void consumer() {
        for (int x : nested_ints()) {
            std::cout << x << " "; // outputs 0 1
        }

        for (int x : manual_ints()) {
            std::cout << x << " "; // also outputs 0 1
        }
    }
\end{colorblock}

\subsection{\tcode{std::ranges::elements_of}}

\tcode{ranges::elements_of} is a utility function that prevents ambiguity when a nested generator type is convertible to the value type
of the present generator

\begin{colorblock}
    generator<int> f()
    {
        co_yield 42;
    }

    generator<any> g()
    {
        co_yield f(); // should we yield 42 or generator<int> ?
    }

\end{colorblock}

To avoid this issue, we propose that:
\begin{itemize}
    \item \tcode{co_yield <expression>} yields the value directly, and
    \item \tcode{co_yield elements_of(<expression>)} yields successive elements the nested generator.
\end{itemize}

For convenience, we further propose that \tcode{co_yield elements_of(x)} be extended to support
yielding the values of arbitrary ranges beyond generators, ie

\begin{colorblock}
    std::generator<int> f()
    {
        std::vector<int> v = /*... */;
        co_yield std::ranges::elements_of(v);
    }

\end{colorblock}

\subsection{Symmetric transfer}

The recursive form can be implemented efficiently with symmetric transfer.
Earlier works in \cite{CppCoro} implemented this feature in a distinct \tcode{recursive_generator} type.

However, it appears that a single type is reasonably efficient thanks to HALO optimizations and symmetric transfer.
The memory cost of that feature is two extra pointers per generator\footnote{
The two pointers in our implementation have non-overlapping active times;
we believe the pair can be optimized into a single pointer's space
with some bit hacking to store a discriminator in the unused lower bits.}.
It is difficult to evaluate the runtime cost of our design given the current coroutine support in compilers.
However our tests show no noticeable difference between a \tcode{generator} and a \tcode{recursive_generator}
which is called non-recursively. It is worth noting that the proposed design makes sure that HALO \cite{P0981R0} optimizations are possible.

While we think a single \tcode{generator} type is sufficient and offers a better API, there are three options:

\begin{itemize}
    \item A single \tcode{generator} type supporting recursive calls (this proposal).

    \item A separate type \tcode{recursive_generator} that can yield values from either a \tcode{recursive_generator} or a \tcode{generator}. That may offer very negligible performance benefits, same memory usage.

    \item A separate {recursive_generator} type which can only yield values from other \tcode{recursive_generator}s.

    That third option would make the following ill-formed:

    \begin{colorblock}
        generator<int> f();
        recursive_generator<int> g() {
            co_yield f(); // incompatible types
        }
    \end{colorblock}

    Instead you would need to write:
    \begin{colorblock}
        recursive_generator<int> g() {
            for (int x : f()) co_yield x;
        }
    \end{colorblock}

    Such a limitation can make it difficult to decide at the time of writing a generator
    coroutine whether or not you should return a \tcode{generator} or \tcode{recursive_generator}
    as you may not know at the time whether or not this particular generator will be used
    within \tcode{recursive_generator} or not.

    If you choose the \tcode{generator} return-type and then later someone wants to yield its
    elements from a \tcode{recursive_generator} then you either need to manually yield its
    elements one-by-one or use a helper function that adapts the \tcode{generator} into a
    \tcode{recursive_generator}. Both of these options can add runtime cost compared to the case where the generator was originally written to return a \tcode{recursive_generator},
    as it requires two coroutine resumptions per element instead of a single coroutine resumption.

    Because of these limitations, we are not recommending this approach.
\end{itemize}

Symmetric transfer is possible for different generator types as long as the \tcode{reference} type is the same, aka,
different value type or allocator type does not preclude symmetric transfer (see the section on allocators).

\section{Allocator support}

In line with the design exploration done in section 2 of \paper{P1681R0}, \tcode{std::generator} supports both stateless and stateful allocators and strives to minimize the interface verbosity for stateless allocators by templating both the generator itself and the \tcode{promise_type}'s \tcode{new} operator
on the allocator type. Details for this interface are found in \paper{P1681R0}.

\tcode{coroutine_parameter_preview_t} such as discussed in section 3 of \paper{P1681R0} has not been explored in this paper.

\begin{colorblock}
    std::generator<int> stateless_example() {
        co_yield 42;
    }

    template <class Allocator>
    std::generator<int> allocator_example(std::allocator_arg_t, Allocator alloc) {
        co_yield 42;
    }

    my_allocator<std::byte> alloc;
    input_range auto rng = allocator_example(std::allocator_arg, alloc);
\end{colorblock}

The proposed interface requires that, if an allocator is provided, it is the second argument to the coroutine function,
immediately preceded by an instance of \tcode{std::allocator_arg_t}.
This approach is necessary to distinguish the allocator desired to allocate the coroutine state from allocators whose purpose is to be used in the body of the coroutine function.
The required argument order might be a limitation if any other argument is required to be the first. However, we cannot think of any scenario where that would be the case.

We think it is important that all standard and user coroutines types can accommodate similar interfaces for allocator support.
In fact, the implementation for that allocator support can be shared amongst \tcode{generator}, \tcode{lazy}, and other standard types.

\textbf{By default \tcode{std::generator} type erases the allocator type, and uses \tcode{std::allocator} unless an allocator is provided to
the coroutine function}.
Then:

\textbf{Type erased allocator(default)}

\begin{colorblock}
template <class Allocator>
std::generator<int> f(std::allocator_arg_t, Allocator alloc) {}

f(std::allocator_arg, my_alloc{});
\end{colorblock}

Returns a generator of type \tcode{std::generator<int, const int\&, void>}
where \tcode{void} denotes that the allocator is type erased.
The allocator is stored in the same allocation as the coroutine state
if it is stateful or not default constructible; a pointer is always stored so that
the \tcode{deallocate} method of the type erased allocator can be called.

\textbf{No allocator}

\begin{colorblock}
std::generator<int> f() {}
f();
\end{colorblock}

Again, returns a generator of type \tcode{std::generator<int, void>}
where \tcode{void} denotes that the allocator is type erased.
A pointer is stored so that
the \tcode{deallocate} method
of the type-erased allocator can be called,
but the default allocator (\tcode{std::allocator})
need not be stored since it is stateless.

\textbf{Explicit stateless allocator}

\begin{colorblock}
std::generator<int, std::stateless_allocator<int>> f() {}
f();
\end{colorblock}

Returns a generator of type
\tcode{std::generator<int, std::stateless_allocator<int>>}
No extra storage is used for the allocator because it is stateless.

\textbf{Explicit stateful allocator}

\begin{colorblock}
std::generator<int, some_stateful_allocator<int>>
    f(std::allocator_arg_t, some_stateful_allocator<int> alloc) {}
f(std::allocator_arg, some_allocator); // must be convertible to some_stateful_allocator
\end{colorblock}

Returns a generator of type \tcode{std::generator<int, some_stateful_allocator<int>>}
The allocator is copied in the coroutine state.

\subsection{Can we postpone adding support for allocator later?}

A case can be made that allocator support could be added to \tcode{std::generator} later.
However, because the proposed design has the allocator as a template parameter,
adding allocator after \tcode{std::generator} ships would represent an ABI break.
We recommend that we add allocator support as proposed in this paper now and make sure that the design remains consistent as work on \tcode{std::lazy}
is made in this cycle.
However, it would be possible to extend support for different mechanisms (such as presented in section 3 of \paper{P1681R0} later.


\subsection{Interaction of symmetric transfer and allocator support}

The allocator must necessarily be part of a coroutine's promise type
since implementations query the promise for allocation functions.
Nonetheless, it would seem silly for a generator to be unable to nest another
generator with identical element type but differing allocator.
For that matter, even differing value types shouldn't be problematic:
the only interface between the generator and the coroutine it wraps
that differs depending on the type arguments to \tcode{generator}
is \tcode{yield_value}.
Ideally, generators would be able to recurse into other generators
whose \tcode{yield_value} has the same parameter type
even if all three template arguments to \tcode{generator} differ.

Our implementation uses a base class to implement the non-allocation behaviors
for \tcode{generator}'s promise so that generators with different allocator types
can yield each other.
Doing so, however, requires that we partially erase
the type of a \tcode{coroutine_handle} so we can resume it later
knowing only that its promise type derives from a particular base.

There are at least two ways to implement this partial type erasure:
\begin{itemize}
\item Storing a pointer in the common base to
  a component with full type knowledge, which can then
  resume the targeted coroutine,
\item Relax the preconditions on some of the \tcode{coroutine_handle} functions
  to allow conversion from
  \tcode{coroutine_handle<void>} to \tcode{coroutine_handle<T>} when
  the source's corresponding \tcode{address()} value was obtained from
  a \tcode{coroutine_handle} referring to a coroutine whose promise object
  is pointer-interconvertible with an object of type \tcode{T}.
\end{itemize}

Our current plan is to standardize
the intent to allow yielding nested generators
with different allocator and value types,
leaving the details of the implementation unspecified,
and to later separately propose the changes to \tcode{coroutine_handle}
that enable that implementation to be maximally efficient.


\section{Implementation and experience}

\tcode{generator} has been provided as part of cppcoro and folly.
However, cppcoro offers a separate \tcode{recursive_generator} type, which is different than the proposed design.

Folly uses a single \tcode{generator} type, which can be recursive but doesn't implement symmetric transfer. Despite that,
Folly users found the use of \tcode{Folly:::Generator} to be a lot more efficient than the eager algorithm they replaced with it.

\tcode{ranges-v3} also implements a \tcode{generator} type, which is never recursive and predates the work on move-only views and
iterators \cite{P1456R1}, \cite{P1207R0} which forces this implementation to ref-count the coroutine handler.

Our implementation \cite{Implementation} consists of a single type that takes advantage of symmetric transfer to implement
recursion - it notably works well with three different major standard libraries.

\section{Performance \& benchmarks}

\begin{note}
These benchmark results are fairly dated now - roughly a year old - and should be taken with a grain of salt.
\end{note}

Because implementations are still being perfected, and because performance is extremely dependant on whether HALO optimization (see \paper{P0981R0})
occurs, it is difficult at this time to make definitive statements about the performance of the proposed design.

At the time of the writing of this paper, Clang is able to inline non-nested coroutines whether the implementation
supports nested coroutines or not, while GCC never performs HALO optimization.

When the coroutine is not inlined, support for recursion does not noticeably impact performance.
And, when the coroutine yields another generator, the performance of the recursive version is noticeably faster than
yielding each element of the range. This is especially noticeable with deep recursion.

\begin{adjustbox}{center}
\texttt{
\begin{threeparttable}
\begin{tabular}{|l?r|r?r|r?r|r|}
    \hline
    & Clang & Clang ST\tnote{1} & GCC & GCC ST\tnote{1} & MSVC & MSVC ST\tnote{1} \\
    \hline
    Single value & (1) 0.235 &  (2) 2.36 & 12.4 & 13.4 & 61.9 & 63.7 \\
    \hline
    Single value, noinline (3) & 13.5  & 13.7 & 14.1 & 15.2 & 63.8 & 64.4\\
    \hline
    Deep nesting & 43670266.0 & (4) 427955.0 & 58801348 & 338736 & 224052033 & 4760914\\
    \hline
\end{tabular}
\begin{tablenotes}
\item[1] Symmetric transfer.
\end{tablenotes}
\end{threeparttable}
}
\end{adjustbox}


The values are expressed in nanoseconds. However, please note that the comparison of the same result across compiler is not meaningful, notably because the MSVC results were obtained on different hardware.
That being said, we observe:

\begin{itemize}
    \item Only Clang can perform constant folding of values yielded by simple coroutine (1)
    \item When the \tcode{generator} supports symmetric transfer, clang is not able to fully inline the generator construction, but HALO is still performed (2).
    \item When HALO is not performed, the relative performance of both approaches is similar (3).
    \item Supporting recursion is greatly beneficial to nested/recursive algorithms (4).
\end{itemize}

The code for these benchmarks, as well as more detailed results, can be found on \href{https://github.com/cor3ntin/coro_benchmark}{Github}.

\newenvironment{draftnote}
    {\color{blue} Drafting Note:}
    {}

\newpage
\section{Wording}

\begin{draftnote}
Wording is relative to Working Draft N4901 \cite{N4901}. \\
Insert in lexicographical order in [version.syn]
(updating \tcode{YYYYXXL} to the date of merge):
\end{draftnote}

\begin{addedblock}
\begin{codeblock}
#define __cpp_lib_generator                       YYYYXXL // also in <generator>
\end{codeblock}
\end{addedblock}

\begin{draftnote}
Modify [ranges.general] as follows:
\end{draftnote}

\rSec2[ranges.general]{General}
This Clause describes components for dealing with ranges of elements.

The following subclauses describe range and view requirements, and
components for range primitives \added{and range generators}
as summarized in Table [tab:range.summary].

\begin{draftnote}
Add a new row at the end of [tab:range.summary] ``Range generators''
with header \tcode{<generator>} referring to
the new subclause [coroutine.generator] added below.
\end{draftnote}

\begin{draftnote}
Add the declaration of \tcode{ranges::elements_of}
to the \tcode{<ranges>} synopsis:
\end{draftnote}

\rSec2[ranges.syn]{Header \tcode{<ranges>} synopsis}

\begin{codeblock}
namespace std::ranges {
[...]

  template<@\libconcept{input_or_output_iterator}@ I, @\libconcept{sentinel_for}@<I> S, subrange_kind K>
  inline constexpr bool enable_borrowed_range<subrange<I, S, K>> = true;

  // [range.dangling], dangling iterator handling
  struct dangling;

\end{codeblock}
\begin{addedblock}
\begin{codeblock}
  // [elementsof.overview], class template elements_of
  template<range R, class Allocator = allocator<byte>>
  class elements_of;
\end{codeblock}
\end{addedblock}
\begin{codeblock}
  template<@\libconcept{range}@ R>
  using borrowed_iterator_t = conditional_t<@\libconcept{borrowed_range}@<R>, iterator_t<R>, dangling>;

  [...]
}
\end{codeblock}

\begin{draftnote}
Insert the following new subclause immediately after [range.dangling]:
\end{draftnote}

\begin{addedblock}

\rSec2[ranges.elementsof]{class template \tcode{elements_of}}

\rSec3[ranges.elementsof.overview]{Overview}

Specializations of \tcode{elements_of} encapsulate a range and
act as a tag in overload sets to disambiguate
when a range should be treated as a sequence
rather than a single value.

\begin{example}
    \begin{codeblock}
        std::generator<any> f(std::ranges::input_range auto&& rng) {
            co_yield rng; // yield rng as a single value
            co_yield std::ranges::elements_of(rng); // yield each element of rng
        }
    \end{codeblock}
\end{example}

\begin{codeblock}
namespace std::ranges {
  template<range R, class Allocator = allocator<byte>>
  class elements_of {
  private:
    [[no_unique_address]] Allocator @\exposid{allocator_}@{}; // \expos
    R&& @\exposid{range_}@; // \expos

  public:
    constexpr explicit elements_of(R&& r)
      noexcept(is_nothrow_default_constructible_v<Allocator>)
      requires default_initializable<Allocator>;

    constexpr explicit elements_of(R&& r, Allocator allocator) noexcept;

    constexpr elements_of(elements_of&&) = default;

    constexpr R&& range() noexcept;
    constexpr Allocator get_allocator() const noexcept;
  };

  template<class R, class Allocator = allocator<byte>>
  elements_of(R&&, Allocator = {}) -> elements_of<R, Allocator>;
}
\end{codeblock}

\rSec3[ranges.elementsof.mem]{Members}

\begin{itemdecl}
constexpr explicit elements_of(R&& r)
  noexcept(is_nothrow_default_constructible_v<Allocator>)
  requires default_initializable<Allocator>;
\end{itemdecl}

\begin{itemdescr}
\effects
Initializes \tcode{\exposid{range_}} with \tcode{std::forward<R>(r)}.
\end{itemdescr}

\begin{itemdecl}
constexpr explicit elements_of(R&& r, Allocator allocator) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects
Initializes \tcode{\exposid{allocator_}} with \tcode{std::move(allocator)} and
\tcode{\exposid{range_}} with \tcode{std::forward<R>(\brk{}r)}.
\end{itemdescr}

\begin{itemdecl}
constexpr R&& range() noexcept;
\end{itemdecl}

\begin{itemdescr}
\returns
\tcode{std::forward<R>(\exposid{range_})}.
\end{itemdescr}

\begin{itemdecl}
constexpr Allocator get_allocator() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\returns
\tcode{\exposid{allocator_}}.
\end{itemdescr}
\end{addedblock}

\begin{draftnote}
Add the following subclause to the end of [ranges]:
\end{draftnote}

\begin{addedblock}
\rSec2[coroutine.generator]{Range Generators}

\rSec3[coroutine.generator.overview]{Overview}
\tcode{generator} presents a view of the elements yielded
by the evaluation of a coroutine.

A \tcode{generator} generates a sequence of elements by
repeatedly resuming the coroutine it was returned from.
When the coroutine is resumed, it is executed until it reaches
either a \tcode{co_yield} statement or the end of the coroutine.
Elements of the sequence are produced by the coroutine
each time a \tcode{co_yield} statement is evaluated.
When the \tcode{co_yield} statement is of the form
\tcode{co_yield elements_of(rng)},
each element of the range \tcode{rng}
is successively produced
as an element of the generator.

\begin{example}
    \begin{codeblock}
        std::generator<int> iota(int start = 0) {
            while (true)
                co_yield start++;
        }

        void f() {
            for (auto i : iota() | std::views::take(3))
                std::cout << i << ' '; // prints 0 1 2
        }
    \end{codeblock}
\end{example}

\rSec3[generator.syn]{Header \tcode{<generator>} synopsis}

\begin{codeblock}
#include <coroutine>
#include <ranges>

namespace std {
  // [coroutine.generator.class], class template \tcode{generator}
  template<class T, class Allocator = void, class U = void>
  class generator;

  template<class T, class Allocator, class U>
  inline constexpr bool ranges::enable_view<generator<T, Allocator, U>> = true;
}
\end{codeblock}

\rSec3[coroutine.generator.class]{Class template \tcode{generator}}

\begin{codeblock}
namespace std {
  template<class T, class Allocator = void, class U = void>
  class generator {
    using @\exposid{value}@ =  // \expos
      conditional_t<is_void_v<U>, remove_cvref_t<T>, U>;
    using @\exposid{reference}@ = // \expos
      conditional_t<is_void_v<U>,
        conditional_t<is_reference_v<T>, T, const T&>,
        T>;
    class @\exposid{iterator}@; // \expos

  public:
    using yielded =
      conditional_t<is_reference_v<@\exposid{reference}@>, @\exposid{reference}@, const @\exposid{reference}@&>;

    class promise_type;

    generator(const generator&) = delete;
    generator(generator&& other) noexcept;

    ~generator();

    generator& operator=(const generator&) = delete;
    generator& operator=(generator&& other) noexcept;

    @\exposid{iterator}@ begin();
    default_sentinel_t end() const noexcept;

  private:
    explicit generator(coroutine_handle<promise_type> coroutine) noexcept; // \expos

    coroutine_handle<promise_type> @\exposid{coroutine_}@ = nullptr; // \expos
  };
}
\end{codeblock}

\mandates \exposid{value} is a cv-unqualified object type.

\mandates \exposid{reference} is either a reference type, or
a cv-unqualified object type that models \libconcept{copy_constructible}.

\tcode{Allocator} shall be \tcode{void}, or
shall either meet the \tcode{Cpp17Allocator} requirements.

\mandates
Let \tcode{RRef} denote \tcode{remove_reference_t<\exposid{reference}>\&\&}
if \exposid{reference} is a reference type,
or \exposid{reference} otherwise.
Each of:
\begin{itemize}
\item \tcode{common_reference_with<\exposid{reference}\&\&, \exposid{value}\&>},
\item \tcode{common_reference_with<\exposid{reference}\&\&, RRef\&\&>}, and
\item \tcode{common_reference_with<RRef\&\&, const \exposid{value}\&>}
\end{itemize}
is modeled.
\begin{note}
These requirements ensure the exposition-only \exposid{iterator} type
can model \tcode{indirectly_readable} and thus \tcode{input_iterator}.
\end{note}

Specializations of \tcode{generator} model \tcode{view} and \tcode{input_range}.

The behavior of a program that adds a specialization
for \tcode{generator} is undefined.

An instance of \tcode{generator} has
an associated stack of coroutines,
which is initially empty.
A coroutine is associated with
at most one \tcode{generator} instance
at a given time.

\rSec3[generator.members]{Members}

\begin{itemdecl}
explicit generator(coroutine_handle<promise_type> coro) noexcept;
\end{itemdecl}

\begin{itemdescr}
Initializes \tcode{\exposid{coroutine_}} with \tcode{coro}.
\end{itemdescr}

\begin{itemdecl}
generator(generator&& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
Initializes \tcode{\exposid{coroutine_}} with \tcode{exchange(other.\exposid{coroutine_}, \{\})}.
\end{itemdescr}

\begin{itemdecl}
~generator();
\end{itemdecl}

\begin{itemdescr}
\effects
Equivalent to:
\begin{codeblock}
    if (@\exposid{coroutine_}@) {
      @\exposid{coroutine_}@.destroy();
    }
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
generator& operator=(generator&& that) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects
Equivalent to:
\begin{codeblock}
    if (auto old = exchange(@\exposid{coroutine_}@, exchange(that.@\exposid{coroutine_}@, {}))) {
      old.destroy();
    }
\end{codeblock}

\returns
\tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
@\exposid{iterator}@ begin();
\end{itemdecl}

\begin{itemdescr}
\expects
\tcode{\exposid{coroutine_}} refers to a coroutine
suspended at its initial suspend-point.

\effects
Equivalent to:
\begin{codeblock}
    @\exposid{coroutine_}@.resume();
    return @\exposid{iterator}@(@\exposid{coroutine_}@);
\end{codeblock}

\remarks
This function pushes \exposid{coroutine_}
onto the \tcode{generator}'s empty stack
of associated coroutines.

\begin{note}
    A program that calls \tcode{begin}
    more than once on the same generator
    has undefined behavior.
\end{note}
\end{itemdescr}

\begin{itemdecl}
default_sentinel_t end() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\returns
\tcode{default_sentinel}.
\end{itemdescr}


\rSec3[coroutine.generator.promise]{class \tcode{generator::promise_type}}

\begin{codeblock}
template<class T, class Allocator, class U>
class generator<T, Allocator, U>::promise_type {
  friend generator;

  add_pointer_t<yielded> @\exposid{value_}@ = nullptr; // \expos

public:
  generator get_return_object() noexcept;

  suspend_always initial_suspend() noexcept;

  auto final_suspend() noexcept;

  suspend_always yield_value(yielded value) noexcept;

  template<class Y = remove_reference_t<yielded>>
    requires is_rvalue_reference_v<yielded> &&
      constructible_from<remove_cvref_t<yielded>, const Y&>
        auto yield_value(const type_identity_t<Y>& lvalue);

  template<class T2, class Alloc2, class U2>
    requires same_as<typename generator<T2, Alloc2, U2>::yielded, yielded>
      auto yield_value(ranges::elements_of<generator<T2, Alloc2, U2>> g) noexcept;

  template<ranges::input_range R, class Alloc2>
    requires convertible_to<ranges::range_reference_t<R>, yielded>
      auto yield_value(ranges::elements_of<R, Alloc2> r) noexcept;

  void await_transform() = delete;

  void return_void() noexcept {}

  void unhandled_exception();

  static void* operator new(size_t size)
    requires same_as<Allocator, void> || default_initializable<Allocator>;

  template<class Alloc, class... Args>
    requires same_as<Allocator, void> || convertible_to<Alloc, Allocator>
      static void* operator new(size_t size, allocator_arg_t, Alloc&& alloc, Args&...);

  template<class This, class Alloc, class... Args>
    requires same_as<Allocator, void> || convertible_to<Alloc, Allocator>
      static void* operator new(size_t size, This&, allocator_arg_t, Alloc&& alloc, Args&...);

  static void operator delete(void* pointer, size_t size) noexcept;
};
\end{codeblock}

\begin{itemdecl}
generator get_return_object() noexcept;
\end{itemdecl}

\begin{itemdescr}
\returns
\tcode{generator\{coroutine_handle<promise_type>::from_promise(*this)\}}.
\end{itemdescr}

\begin{itemdecl}
suspend_always initial_suspend() noexcept;
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{\{\}}.
\end{itemdescr}

\begin{itemdecl}
auto final_suspend() noexcept;
\end{itemdecl}

\begin{itemdescr}
\expects
The coroutine whose promise object is \tcode{*this} is at the top of the stack
of associated coroutines of some \tcode{generator} instance \tcode{x}.

\returns
An awaitable object of unspecified type
whose member \tcode{await_suspend}
removes the coroutine whose promise is \tcode{*this}
from the top of \tcode{x}'s stack of associated coroutines,
and resumes execution of the new top-of-stack coroutine, if any.
\end{itemdescr}

\begin{itemdecl}
suspend_always yield_value(yielded x) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects
Equivalent to:
\tcode{\exposid{value_} = addressof(x)}.

\returns
\tcode{\{\}}.
\end{itemdescr}

\begin{itemdecl}
template<class Y = remove_reference_t<yielded>>
  auto yield_value(const type_identity_t<Y>& lvalue)
    requires is_rvalue_reference_v<yielded> &&
      constructible_from<remove_cvref_t<yielded>, const Y&>;
\end{itemdecl}

\begin{itemdescr}
\returns
An object of an unspecified awaitable type~([expr.await])
that stores an object of type \tcode{remove_cv_t<Y>}
direct-non-list-initialized with \tcode{lvalue},
whose member functions arrange for
\tcode{\exposid{value_}} to point at that stored object
before suspending the coroutine.

\throws
Any exception thrown by the initialization of the stored object.
\end{itemdescr}

\begin{itemdecl}
template<class T2, class Alloc2, class U2>
  requires same_as<typename generator<T2, Alloc2, U2>::yielded, yielded>
    auto yield_value(ranges::elements_of<generator<T2, Alloc2, U2>> g) noexcept;
\end{itemdecl}

\begin{itemdescr}
\expects
The coroutine whose promise object is \tcode{*this} is at the top of the stack
of associated coroutines of some \tcode{generator} instance \tcode{x}.

\returns
An object of an unspecified awaitable type~([expr.await])
which takes ownership of the generator \tcode{g}, whose member \tcode{await_suspend}
pushes \tcode{g.\exposid{coroutine_}} atop the stack of
coroutines associated with \tcode{x}
before resuming execution of \tcode{g.\exposid{coroutine_}}, and
whose member \tcode{await_resume} rethrows any exception captured by
a call to \tcode{g.\exposid{coroutine_}.promise()}'s member
\tcode{unhandled_exception}.

\begin{note}
Variables with automatic storage duration in the scope of
the coroutine represented by \tcode{g.\exposid{coroutine_}} are destroyed
before variables with automatic storage duration in the scope of
the coroutine whose promise object is \tcode{*this}.
\end{note}
\end{itemdescr}

\begin{itemdecl}
template<ranges::input_range R, class Alloc2>
  requires convertible_to<ranges::range_reference_t<R>, yielded>
    auto yield_value(ranges::elements_of<R, Alloc2> r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects
Equivalent to:
\begin{codeblock}
    auto nested = [](allocator_arg_t, Alloc2, auto* range_ptr)
      -> generator<yielded, Alloc2, ranges::range_value_t<R>> {
        for (auto&& e : *range_ptr)
          co_yield static_cast<yielded>(std::forward<decltype(e)>(e));
      };
    auto&& rng = r.range();
    return yield_value(ranges::elements_of(nested(
      allocator_arg, r.get_allocator(), addressof(rng))));
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
void unhandled_exception();
\end{itemdecl}

\begin{itemdescr}
\expects
The coroutine whose promise object is \tcode{*this} is at the top of the stack
of associated coroutines of some \tcode{generator} instance \tcode{x}.

\effects
If the coroutine whose promise object is \tcode{*this}
is the sole element of \tcode{x}'s stack of associated coroutines,
equivalent to: \tcode{throw}.
Otherwise, stores the result of \tcode{current_exception()}
where it can later be retrieved and rethrown by the \tcode{await_resume}
member of the awaitable object returned from the \tcode{yield_value} call
that pushed this coroutine onto \tcode{x}'s stack of associated coroutines.
\end{itemdescr}

\begin{itemdecl}
static void* operator new(size_t size)
  requires same_as<Allocator, void> || default_initializable<Allocator>;
\end{itemdecl}

\begin{itemdescr}
Let \tcode{A} be \tcode{allocator<void>}
if \tcode{Allocator} denotes \tcode{void},
or \tcode{Allocator} otherwise.
Let \tcode{BAlloc} be \tcode{allocator_traits<A>::template rebind_alloc<U>}
where \tcode{U} denotes an unspecified type whose size and alignment
are both \tcode{_STDCPP_DEFAULT_NEW_ALIGNMENT__}.

\effects
Initializes an allocator of type \tcode{BAlloc} with \tcode{A\{\}},
and uses that object to allocate the smallest number of blocks that
provide sufficient storage for:
\begin{itemize}
\item a coroutine state of size \tcode{size},
\item if \tcode{allocator_traits<BAlloc>::is_always_equal::value} is \tcode{false},
space to store a copy of the allocator, and
\item if \tcode{Allocator} denotes \tcode{void},
any additional state necessary to ensure that
\tcode{operator delete} can later deallocate this memory block
with an allocator equal to the allocator used here.
\end{itemize}

\returns
A pointer to the space allocated for the coroutine state.
\end{itemdescr}

\begin{itemdecl}
template<class Alloc, class... Args>
  requires same_as<Allocator, void> || convertible_to<Alloc, Allocator>
    static void* operator new(size_t size, allocator_arg_t, Alloc&& alloc, Args&...);

template<class This, class Alloc, class... Args>
  requires same_as<Allocator, void> || convertible_to<Alloc, Allocator>
    static void* operator new(size_t size, This&, allocator_arg_t, Alloc&& alloc, Args&...);
\end{itemdecl}

\begin{itemdescr}
Let \tcode{A} be \tcode{allocator<void>}
if \tcode{Allocator} denotes \tcode{void},
or \tcode{Allocator} otherwise.
Let \tcode{BAlloc} be \tcode{allocator_traits<A>::template rebind_alloc<U>}
where \tcode{U} denotes an unspecified type whose size and alignment
are both \tcode{_STDCPP_DEFAULT_NEW_ALIGNMENT__}.

\effects
Initializes an allocator of type \tcode{BAlloc}
with \tcode{A(std::forward<Alloc>(alloc))},
and uses that object to allocate the smallest number of blocks that
provide sufficient storage for:
\begin{itemize}
\item a coroutine state of size \tcode{size},
\item if \tcode{allocator_traits<BAlloc>::is_always_equal::value} is \tcode{false}
or \tcode{default_initial\-izable<BAlloc>} is \tcode{false},
space to store a copy of the allocator, and
\item if \tcode{Allocator} denotes \tcode{void},
any additional state necessary to ensure that
\tcode{operator delete} can later deallocate this memory block
with an allocator equivalent to the allocator used here.
\end{itemize}

\returns
A pointer to the space allocated for the coroutine state.
\end{itemdescr}

\begin{itemdecl}
static void operator delete(void* pointer, size_t size) noexcept;
\end{itemdecl}

\begin{itemdescr}
\expects
\tcode{pointer} was returned from an invocation of
one of the above overloads of \tcode{operator new}
with a \tcode{size} argument equal to \tcode{size}.

\effects
Deallocates the block of allocator memory
that includes the coroutine state denoted by \tcode{pointer}
using an allocator equivalent to the one that was used to allocate it.
\end{itemdescr}

\rSec3[coroutine.generator.iterator]{Class template \tcode{generator::\exposid{iterator}}}

\begin{codeblock}
template<class T, class Allocator, class U>
class generator<T, Allocator, U>::@\exposid{iterator}@ {
public:
    using value_type = @\exposid{value}@;
    using difference_type = ptrdiff_t;

    @\exposid{iterator}@(@\exposid{iterator}@&& other) noexcept;

    @\exposid{iterator}@& operator=(@\exposid{iterator}@&& other) noexcept;

    @\exposid{reference}@ operator*() const noexcept(is_nothrow_copy_constructible_v<@\exposid{reference}@>);

    @\exposid{iterator}@& operator++();
    void operator++(int);

    bool operator==(default_sentinel_t) const noexcept;

private:
    friend class generator;

    explicit @\exposid{iterator}@(coroutine_handle<promise_type> coroutine) noexcept; // \expos

    coroutine_handle<promise_type> @\exposid{coroutine_}@; // \expos
};
\end{codeblock}

\begin{itemdecl}
@\exposid{iterator}@(@\exposid{iterator}@&& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects
Initializes \tcode{\exposid{coroutine_}}
with \tcode{exchange(other.\exposid{coroutine_}, \{\})}.
\end{itemdescr}

\begin{itemdecl}
@\exposid{iterator}@& operator=(@\exposid{iterator}@&& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects
Equivalent to:
\tcode{\exposid{coroutine_} = exchange(other.\exposid{coroutine_}, \{\});}
\end{itemdescr}

\begin{itemdecl}
@\exposid{reference}@ operator*() const noexcept(is_nothrow_copy_constructible_v<@\exposid{reference}@>);
\end{itemdecl}

\begin{itemdescr}
\expects
\tcode{\exposid{coroutine_}.done()} is \tcode{false}, and \exposid{coroutine_}

Let \tcode{p} be the promise object of the coroutine
at the top of the stack of coroutines associated with
the \tcode{generator} whose stack of associated coroutines
includes \exposid{coroutine_}.

\effects
Equivalent to:
\begin{codeblock}
    return static_cast<@\exposid{reference}@>(*p.@\exposid{value_}@);
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
@\exposid{iterator}@& operator++();
\end{itemdecl}

\begin{itemdescr}
\expects
\tcode{\exposid{coroutine_}.done()} is \tcode{false}.

\effects
Resumes the coroutine at the top of the stack of coroutines associated with
the \tcode{generator} whose stack of associated coroutines
includes \exposid{coroutine_}.

\returns
\tcode{return *this};
\end{itemdescr}

\begin{itemdecl}
void operator++(int);
\end{itemdecl}

\begin{itemdescr}
\expects
\tcode{\exposid{coroutine_}.done()} is \tcode{false}.

\effects
Equivalent to: \tcode{++*this}.
\end{itemdescr}

\begin{itemdecl}
bool operator==(default_sentinel_t) const noexcept;
\end{itemdecl}

\begin{itemdescr}
\returns
\tcode{\exposid{coroutine_}.done()}.
\end{itemdescr}

\begin{itemdecl}
explicit @\exposid{iterator}@(coroutine_handle<promise_type> coroutine) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects
Initializes \tcode{\exposid{coroutine_}} with \tcode{coroutine}.
\end{itemdescr}

\end{addedblock}

\newpage
\section{References}
\renewcommand{\section}[2]{}%
\bibliographystyle{plain}
\bibliography{wg21}

\begin{thebibliography}{9}
    \bibitem[CppCoro]{CppCoro}
    Lewis Baker
    \emph{CppCoro: A library of C++ coroutine abstractions for the coroutines TS}\newline
    \url{https://github.com/lewissbaker/cppcoro}

    \bibitem[Folly]{Folly}
    Facebook
    \emph{Folly: An open-source C++ library developed and used at Facebook}\newline
    \url{https://github.com/facebook/folly}


    \bibitem[range]{range-v3}
    Eric Niebler
    \emph{range-v3 Range library for C++14/17/20}\newline
    \url{https://github.com/ericniebler/range-v3}

    \bibitem[Implementation]{Implementation}
    Casey Carter, Lewis Baker, Corentin Jabot
    \emph{\tcode{std::generator} implementation}\newline
    \url{https://godbolt.org/z/1Go9oxPWz}

\end{thebibliography}

\end{document}
