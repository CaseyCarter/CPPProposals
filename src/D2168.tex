% !TeX program = luatex
% !TEX encoding = UTF-8

\RequirePackage{luatex85}%
\documentclass{wg21}
\usepackage{threeparttable}
\usepackage{adjustbox}
\usepackage{xcolor,colortbl}
\usepackage{array}
\newcolumntype{?}{!{\vrule width 1pt}}

\title{\tcode{std::generator}: Synchronous Coroutine Generator for Ranges}
\docnumber{D2168R5}
\audience{LEWG}
\author{Casey Carter}{Casey@Carter.net}
\authortwo{Lewis Baker}{lewissbaker@gmail.com}
\authorthree{Corentin Jabot}{corentin.jabot@gmail.com}

\begin{document}
\maketitle


\section{Abstract}

We propose a standard library type \tcode{std::generator}
which implements a coroutine generator
that models \tcode{std::ranges::input_range}.


\section{Revisions}

\subsection{R5}
\begin{itemize}
\item Reorder \tcode{generator}'s first two template parameters,
  so the value type precedes the reference type.
  This allows the reference type to be more easily defaulted,
  which feels more consistent with the R4 design.
\item Remove concerns about the $\bigoh{1}$ destruction requirement for \tcode{view},
  which has been relaxed by P2415R2 ``What is a view?'' \cite{P2415R2}.
\end{itemize}

\subsection{R4}
\begin{itemize}
\item Wording improvements
\end{itemize}

\subsection{R3}
\begin{itemize}
\item Wording improvements
\end{itemize}

\subsection{R2}
\begin{itemize}
\item Some wording fixes
\item Improve the section on allocator support
\item Updated implementation
\end{itemize}

\subsection{R1}
\begin{itemize}
\item Add benchmarks results and discussion about performance
\item Introduce \tcode{elements_of} to avoid ambiguities when a generator is convertible to the reference type of the parent generator.
\item Add allocator support
\item Symmetric transfer works with generators of different value / allocator types
\item Remove \tcode{iterator::operator->}
\item Put \tcode{generator} in a new \tcode{<generator>} header.
\item Add an other example to motivate the \tcode{Value} template parameter
\end{itemize}


\section{Example}

\begin{colorblock}
    std::generator<int> fib() {
        auto a = 0, b = 1;
        while (true) {
            co_yield std::exchange(a, std::exchange(b, a + b));
        }
    }

    int answer_to_the_universe() {
        auto rng = fib() | std::views::drop(6) | std::views::take(3);
        return std::ranges::fold_left(std::move(range), 0, std::plus{});
    }
\end{colorblock}


\section{Motivation}

C++ 20 had very minimalist library support for coroutines.
Synchronous generators are an important use case for coroutines,
one that cannot be supported
without the machinery presented in this paper.
Writing an efficient recursive generator is non-trivial;
the standard should provide one.


\section{Design}

While the proposed \tcode{std::generator} interface is fairly straightforward, a few decisions are worth pointing out.

\subsection{\tcode{input_view}}

\tcode{std::generator} is a move-only \tcode{view} which models \tcode{input_range} and has move-only iterators.
This is because the coroutine state is a unique resource (even if the coroutine \textit{handle} is copyable).


\subsection{Header}

Multiple options are available as to where to put the \tcode{generator} class.

\begin{itemize}
    \item \tcode{<coroutine>}, but \tcode{<coroutine>} is a low level header,
      and \tcode{generator} depends on bits of \tcode{<type_traits>} and \tcode{<iterator>}.

    \item \tcode{<ranges>}

    \item A new \tcode{<generator>}

\end{itemize}

\section{Reference type}

\tcode{generator} has 3 template parameters:

\tcode{generator<Value, Reference = const Value\&, Allocator = void>}

\begin{itemize}
\item a \tcode{Value} type,
  a \cv-unqualified object type that specifies the value type
  of the \tcode{generator}'s range and iterators,
\item a \tcode{Reference} type that specifies the reference type
  of the \tcode{generator}'s range and iterators, and
\item an \tcode{Allocator} type that is rebound to allocate the coroutine state,
  which can be \tcode{void} to type-erase
  any allocator specified as a coroutine argument,
  defaulting to \tcode{allocator<byte>} when none is specified.
\end{itemize}

Only the first parameter is required, and
we expect most users to concern themselves with that first parameter,
as good defaults are provided for the other two.
The first parameter controls the iterator's value type, and
- indirectly via the default - its reference type.
The reference type in turn informs
the types passed to \tcode{yield_value}.
This first parameter, therefore, does a lot of heavy lifting.

\subsection{Obsolete discussion about reference specification}

\begin{note}
Before R5, \tcode{generator}'s first parameter
\tcode{Type} denoted the reference type of the range / iterators, and
the value type was defaulted to \tcode{remove_cvref_t<Type>}.
The following sections of design discussion are written
in terms of that ordering for continuity.
The ``R5 adjustment'' section will describe our rationale
for reordering the first two parameters and
how the result relates to the older design discussed here.
\end{note}

In earlier versions of this paper,
the reference type was exactly the first template parameter.
This had the advantage of being simple.
But it was a terrible performance trap:

Consider the behavior of the following code assuming the reference type is exactly the first template argument:

\begin{colorblock}
std::generator<std::string> f() {
    std::string hello = "hello";
    co_yield hello;   // 0 or 1 copy depending on implementation
    co_yield "Hello"; // 1 copy (conversion from const char* to std::string)
}

for (auto&& str : f()) {} // 1 copy (*it returns std::string)
\end{colorblock}

Of course the solution, which we advocated for, is for the user to manually specify an explicit reference type:

\begin{colorblock}
    generator<const std::string&> f() {
        std::string hello = "hello";
        co_yield hello;   // 0 or 1 copy depending on implementation
        co_yield "Hello"; // 1 copy (conversion from const char* to std::string)
    }

    for (auto&& str : f()) {} // 0 copy
\end{colorblock}

This works, can be explained, and is even logical. You get what you asked for.
It is nonetheless surprising for non-experts that using the simple \tcode{generator<string>} would create 2 copies per \tcode{co_yield}.

To hope users would not routinely forget
to use a reference type when using \tcode{std::generator}
calls for a heaping barrel of optimism.

We later proposed that for a \tcode{generator<T>},
its reference type be \tcode{conditional_t<is_reference_v<T>, T, const T\&>}.

\newcommand{\cellif}{\cellcolor{red!25}Ill-formed}
\newcommand{\cellid}{\cellcolor{red!70}Ill-formed}
\newcommand{\cellbl}{\cellcolor{green!70}0}
\newcommand{\cellzr}{\cellcolor{green!25}0}
\newcommand{\cellon}{\cellcolor{orange!25}1}


\begin{tabular}{|c|c|c|c|}
\hline
First parameter       & reference type        & default value & can yield mutable lvalue ref? \\ \hline
\tcode{int}           & \tcode{const int\&}   & \tcode{int}   & No                            \\ \hline
\tcode{const int\&}   & \tcode{const int\&}   & \tcode{int}   & No                            \\ \hline
\tcode{int\&}         & \tcode{int\&}         & \tcode{int}   & Yes                           \\ \hline
\tcode{int\&\&}       & \tcode{int\&\&}       & \tcode{int}   & No                            \\ \hline
\tcode{const int\&\&} & \tcode{const int\&\&} & \tcode{int}   & No                            \\ \hline
\end{tabular}

Attempts have been made to characterize the exact relations between reference, value, storage, and \tcode{co_yield} exception types and categories.
Ultimately, a simpler mental model is to characterize what expressions can be yielded for a given reference type and how many copies are made for each scenario.

\begin{tabular}{|c|c|c|c|c|}
\hline
First parameter & \tcode{co_yield const T\&} & \tcode{co_yield T\&} & \tcode{co_yield T\&\&} & \tcode{co_yield U\&\&} \\ \hline
\tcode{T}           & \cellbl & \cellbl & \cellbl & \cellon \\ \hline
\tcode{const T\&}   & \cellzr & \cellzr & \cellzr & \cellon \\ \hline
\tcode{T\&}         & \cellif & \cellzr & \cellif & \cellif \\ \hline
\tcode{T\&\&}       & \cellif & \cellif & \cellzr & \cellon \\ \hline
\tcode{const T\&\&} & \cellif & \cellif & \cellzr & \cellon \\ \hline
\end{tabular}

In this table, we see that only \tcode{co_yield} that requires conversion incurs copy, which is expected.
Coroutines guarantee that the yielded expression exceeds the lifetime of the \tcode{co_yield} expression,
so \tcode{generator} can usefully store
a pointer to the object denoted by a yielded xvalue.

\tcode{co_yield} expressions involving conversion can store the yielded value in an awaiter.
The type of the stored expression is the reference type with its reference qualifiers stripped, but that is an implementation
detail that is not observable and is therefore of limited interest. Of course, that type needs to be constructible from yielded values.

Besides the \tcode{T} case, this behaves very much like returning from a function that is intended.

\subsection{Move-only and immovable types}
LEWG was interested in how this works with \tcode{generator} of move-only and immovable types.

\begin{tabular}{|c|c|c|c|}
\hline
First parameter & \tcode{co_yield const T\&} & \tcode{co_yield T\&} & \tcode{co_yield T\&\&} \\ \hline
\tcode{move_only}           & \cellbl & \cellbl & \cellbl \\ \hline
\tcode{const move_only\&}   & \cellzr & \cellzr & \cellzr \\ \hline
\tcode{move_only\&}         & \cellif & \cellzr & \cellif \\ \hline
\tcode{move_only\&\&}       & \cellif & \cellif & \cellzr \\ \hline
\tcode{const move_only\&\&} & \cellif & \cellif & \cellzr \\ \hline \hline

\tcode{immovable}           & \cellbl & \cellbl & \cellbl \\ \hline
\tcode{const immovable\&}   & \cellzr & \cellzr & \cellzr \\ \hline
\tcode{immovable\&}         & \cellif & \cellzr & \cellif \\ \hline
\tcode{immovable\&\&}       & \cellif & \cellif & \cellzr \\ \hline
\tcode{const immovable\&\&} & \cellif & \cellif & \cellzr \\ \hline
\end{tabular}

As that table shows, these types work exactly like other types.
However, to be able to move from a move only reference type, the coroutine has to explicitely state so:

\begin{colorblock}
auto f = []() -> std::generator<move_only> { co_yield move_only{}; }();
for (auto&& x : f) {
    move_only mo = std::move(x); // ill-formed, decltype(x) is const move_only&
}

auto f = []() -> std::generator<move_only&&> { co_yield move_only{}; }();
for (auto&& x : f) {
    move_only mo = x; // ok
}

auto f = []() -> std::generator<move_only&> { move_only m; co_yield m; }();
for (auto&& x : f) {
    move_only mo = std::move(x); // dicey but okay
}
\end{colorblock}

\subsection{Potential downsides}
\begin{colorblock}
auto f = []() -> std::generator<MyType> {
    MyType t;
    co_yield std::move(t);
}();
\end{colorblock}

In the example above \tcode{std::move} doesn't move. Arguably more than usual.
Indeed the code expands to something similar to:

\begin{colorblock}
auto&& __temp = std::move(t);
yield_value(_temp); // <=> promise.value = std::addressof(__temp); // no move
\end{colorblock}

Of course, a move would not have occurred for a \tcode{std::generator<const MyType\&>} either as these things are identical.
It might be suprising?
The only way to avoid that is to create temporary value for rvalue reference, which would force a move to actually occurs,
at the cost of performance.

\subsection{Alternatives considered}

\subsubsection{Mandating a reference as the first parameter}

We could make \tcode{generator<int>} ill-formed and force people to specify a reference type like \tcode{generator<const int\&>}.
We do not think this is very user-friendly, given that we can provide a reasonable default.

We rejected this option.

\subsubsection{Using \tcode{T\&} as the default}

There are two issues with mutable references:
\begin{itemize}
\item They are mutable (They allow mutating the coroutine frame), which would be an \emph{interesting} default.
\item They are very restrictive as to the set of \tcode{co_yield} expression allowed with them.
\end{itemize}

We rejected this option.

\subsubsection{Using \tcode{T\&\&} as the default}

This avoids a copy when doing \tcode{auto object = *it} (where it is a \tcode{std::generator::iterator}),
but it is very easy to misuse, consider:

\begin{colorblock}
auto f = []() -> std::generator<std::string> { co_yield "footgun"; }();
for (auto&& x : f) {
    auto y = x; // nothing suggest a move
    y.transform();
    if (x != y) {
        // always triggers, likely to be surprising
    }
}
\end{colorblock}

We rejected this option.

\subsubsection{Doing something clever for move-only types}

We considered returning \tcode{T\&} for move_only types so that they can be moved from by default.
We realized this was too clever and inconsistent.
Notably, adding a copy constructor to \tcode{T} would change the meaning of the code.

We rejected this option.

\subsubsection{Doing something clever for reference types}

By default \tcode{generator<reference_wrapper<T>>} could yield \tcode{reference_wrapper<T>} has that is already a "reference-like" type.
However, no other view does that, "reference-like" is fuzzily defined, and this would probably cause more trouble than it's worth.

We rejected this option.

\subsubsection{Keeping the R4 design}

Returning values has the potential to severely impact performance, is inconsistent with other views, and is not necessary.
It also did not work with move-only types.

The change, along with an implementation strategy described in the "How to store the yielded value in the promise type?" guarantees that
no copy needs to be made if the reference and yielded types are the same (with qualifiers stripped).

We think this new approach keeps the simplicity of the original design, improves performance, and works with more types.

Thank you LEWG, and in particular Mathias, for highlighting these concerns!

\subsection{R5 adjustment}

It is unfortunate that the R4 design silently alters
the user's specified reference type,
and that in doing so it effectively forbids non-reference reference types.
Ranges with proxy reference types especially would like
to be able to yield prvalues of class type (proxy references), and
it would be preferable to avoid a design that makes it impossible to do so.

We observed that reordering the reference and value type parameters
allows the reference type to be defaulted to a function of the value type,
and that we could choose that function so as to avoid the pitfall that an inadvertent choice of a non-reference reference type
can introduce additonal copies.

In R5, \tcode{generator}'s first parameter \tcode{Value} names
the value type of the range and iterators,
and the second parameter \tcode{Reference} names
the reference type of the range and iterators.
The reference type must be either a core language reference -
so \tcode{*i} for an iterator \tcode{i} is a glvalue -
or a copy-constructible \cv-unqualified object type -
so \tcode{*i} is a prvalue.
We preserve the prior design's feature that yielded values must convert to
\tcode{conditional_t<is_reference_v<Reference>, Reference, const Reference\&>}
which allows implementations to either store a pointer to the converted glvalue in the coroutine promise or stash a the value in an awaitable returned from \tcode{yield_value}.

This approach keeps the desirable features of the R4 design,
making simple things simple,
but also makes complex things possible.
Presumably a user who goes to the trouble of explicitly specifying
the reference type can be trusted to determine if their program can tolerate
the expense of copy-constructing a new prvalue to yield from each iterator dereference.

\subsection{Separately specifyable Value Type}

This proposal supports specifying both the "yielded" type, which is the iterator's reference type (not required to be a reference) and its corresponding value type.
This allow ranges to handle proxy types and wrapped \tcode{reference}, like this implementation of \tcode{zip}:

\begin{colorblock}
namespace ranges = std::ranges;

template<ranges::input_range Rng1, ranges::input_range Rng2>
std::generator<
    std::tuple<ranges::range_value_t<Rng1>, ranges::range_value_t<Rng2>>,
    std::tuple<ranges::range_reference_t<Rng1>, ranges::range_reference_t<Rng2>>>
zip(Rng1 r1, Rng2 r2) {
    auto it1 = ranges::begin(r1);
    auto it2 = ranges::begin(r2);
    auto end1 = ranges::end(r1);
    auto end2 = ranges::end(r2);
    for (; it1 != end1 && it2 != end2; ++it1, ++it2) {
        co_yield {*it1, *it2};
    }
}
\end{colorblock}

In this second example, using \tcode{string} as value type ensures that calling code can take the necessary steps
to make sure iterating over a generator would not invalidate any of the yielded values.

\begin{colorblock}
// Yielding string literals : always fine
std::generator<std::string_view, std::string_view> string_views() {
    co_yield "foo";
    co_yield "bar";
}

std::generator<std::string, std::string_view> strings() {
    co_yield "start";
    std::string s;
    for (auto sv : string_views()) {
        s = sv;
        s.push_back('!');
        co_yield s;
    }
    co_yield "end";
}

// conversion to a vector of strings
// If the value_type was string_view, it would convert to a vector of string_view,
// which would lead to undefined behavior operating on elements of v that were
// invalidated while iterating through the generator.
auto v = std::ranges::to<vector>(strings()); // (@{\paper{P1206R3}}@)
\end{colorblock}


\subsection{How to store the yielded value in the promise type?}

There are multiple implementation strategies possible to store the value in the generator.
An early revision of this paper always stored a copy of the yielded value, leading to an extra copy.
When a copy needs to be made by \tcode{yield_value} (because the yielded value is not of the same type or cannot bind to the reference type), we can store the value in an awaiter that will remain alive until the end of the co_yield expression:

\begin{colorblock}
    std::suspend_always yield_value(const Ref& x) {
        auto& root = rootOrLeaf_.promise();
        root.valuePtr_ = std::addressof(x);
        return {};
    }

    std::suspend_always yield_value(Ref& x) {
        auto& root = rootOrLeaf_.promise();
        root.valuePtr_ = std::addressof(x);
        return {};
    }

    template<typename T = std::remove_cvref_t<Ref>>
        requires (!is_reference_v<Ref> && is_constructible_v<Ref, T>)
    auto yield_value(T&& x) {
        struct yield_value_holder {
            Ref ref;

            bool await_ready() noexcept { return false; }

            template<typename Promise>
            void await_suspend(coroutine_handle<Promise> h) noexcept {
                h.promise().valuePtr_ = addressof(ref);
            }
            void await_resume() noexcept {}
        };
        return yield_value_holder{forward<T>(x)};
    }
\end{colorblock}

% FIXME: Is this still true?
To support this implementation strategy, the wording does not specify a type for the return value of \tcode{yield_value}.

However, the yielded expression is guaranteed to be alive
until the coroutine resumes.
It is, therefore, sufficient to store its address.
We can take advantage of that fact by storing only a pointer in the generator.

A drawback of this solution is that the yielded value is only destroyed at the end of the
full expression:
\begin{colorblock}
    (co_yield x, co_yield y); // x is destroyed after y is yielded.
\end{colorblock}

We think this is a reasonable tradeoff as
it avoids the copy needed on the older approach.
Further optimization could be done to copy small values - and avoid an indirection.
But it is unclear what the cost of this indirection is, as none of these accesses should result in cache misses).

\subsection{Recursive generator}

A "recursive generator" is a coroutine that supports the ability to directly \tcode{co_yield}
a generator of the same type as a way of emitting the elements of that \tcode{generator}
as elements of the current \tcode{generator}.

Example: A \tcode{generator} can \tcode{co_yield} other generators of the same type
\begin{colorblock}
    std::generator<const std::string&> delete_rows(std::string table, std::vector<int> ids) {
        for (int id : ids) {
            co_yield std::format("DELETE FROM {0} WHERE id = {1};", table, id);
        }
    }

    std::generator<const std::string&> all_queries() {
        co_yield std::ranges::elements_of(delete_rows("user", {4, 7, 9 10}));
        co_yield std::ranges::elements_of(delete_rows("order", {11, 19}));
    }
\end{colorblock}

Example: A \tcode{generator} can also be used recursively
\begin{colorblock}
    using namespace std;

    struct Tree {
        Tree* left;
        Tree* right;
        int value;
    };

    generator<int> visit(Tree& tree) {
        if (tree.left) co_yield ranges::elements_of(visit(*tree.left));
        co_yield tree.value;
        if (tree.right) co_yield ranges::elements_of(visit(*tree.right));
    }
\end{colorblock}

In addition to being more concise, the ability to directly yield a nested generator has some
performance benefits compared to iterating over the contents of the nested generator and
manually yielding each of its elements.

Yielding a nested \tcode{generator} allows the consumer of the top-level coroutine to
directly resume the current leaf generator when incrementing the iterator, whereas a solution that has each generator manually iterating over elements of the child generator
requires O(depth) coroutine resumptions/suspensions per element of the sequence.

Example: Non-recursive form incurs O(depth) resumptions/suspensions per element
and is more cumbersome to write

\begin{colorblock}
    using namespace std;

    generator<int> slow_visit(Tree& tree) {
        if (tree.left) {
            for (int x : ranges::elements_of(visit(*tree.left)))
                co_yield x;
        }
        co_yield tree.value;
        if (tree.right) {
            for (int x : ranges::elements_of(visit(*tree.right)))
                co_yield x;
        }
    }
\end{colorblock}

Exceptions that propagate out of the body of nested \tcode{generator} coroutines
are rethrown into the parent coroutine from the \tcode{co_yield} expression rather
than propagating out of the top-level \tcode{iterator::operator++()}. This follows the mental model that \tcode{co_yield someGenerator} is semantically equivalent to manually
iterating over the elements and yielding each element.

For example: \tcode{nested_ints()} is semantically equivalent to \tcode{manual_ints()}
\begin{colorblock}
    std::generator<int> might_throw() {
        co_yield 0;
        throw some_error{};
    }

    std::generator<int> nested_ints() {
        try {
            co_yield std::ranges::elements_of(might_throw());
        } catch (const some_error&) {}
        co_yield 1;
    }

    // nested_ints() is semantically equivalent to the following:
    std::generator<int> manual_ints() {
        try {
            for (int x : might_throw()) {
                co_yield x;
            }
        } catch (const some_error&) {}
        co_yield 1;
    }

    void consumer() {
        for (int x : nested_ints()) {
            std::cout << x << " "; // outputs 0 1
        }

        for (int x : manual_ints()) {
            std::cout << x << " "; // also outputs 0 1
        }
    }
\end{colorblock}

\subsection{\tcode{std::ranges::elements_of}}

\tcode{ranges::elements_of} is a utility function that prevents ambiguity when a nested generator type is convertible to the value type
of the present generator

\begin{colorblock}
    generator<int> f()
    {
        co_yield 42;
    }

    generator<any> g()
    {
        co_yield f(); // should we yield 42 or generator<int> ?
    }

\end{colorblock}

To avoid this issue, we propose that:

\begin{itemize}
    \item \tcode{co_yield <expression>} always yield the value directly.
    \item \tcode{co_yield elements_of(<expression>)} yield the values of the nested generator.
\end{itemize}


For convenience, we further propose that \tcode{co_yield elements_of(x)} be extended to support
yielding the values of arbitrary ranges beyond generators, ie

\begin{colorblock}
    std::generator<int> f()
    {
        std::vector<int> v = /*... */;
        co_yield std::ranges::elements_of(v);
    }

\end{colorblock}

\subsection{Symmetric transfer}

The recursive form can be implemented efficiently with symmetric transfer.
Earlier works in \cite{CppCoro} implemented this feature in a distinct \tcode{recursive_generator} type.

However, it appears that a single type is reasonably efficient thanks to HALO optimizations and symmetric transfer.
The memory cost of that feature is three extra pointers per generator.
It is difficult to evaluate the runtime cost of our design given the current coroutine support in compilers.
However our tests show no noticeable difference between a \tcode{generator} and a \tcode{recursive_generator}
which is called non-recursively. It is worth noting that the proposed design makes sure that HALO \cite{P0981R0} optimizations are possible.

While we think a single \tcode{generator} type is sufficient and offers a better API, there are three options:

\begin{itemize}
    \item A single \tcode{generator} type supporting recursive calls (this proposal).

    \item A separate type \tcode{recursive_generator} that can yield values from either a \tcode{recursive_generator} or a \tcode{generator}. That may offer very negligible performance benefits, same memory usage.

    \item A separate {recursive_generator} type which can only yield values from other \tcode{recursive_generator}s.

    That third option would make the following ill-formed:

    \begin{colorblock}
        generator<int> f();
        recursive_generator<int> g() {
            co_yield f(); // incompatible types
        }
    \end{colorblock}

    Instead you would need to write:
    \begin{colorblock}
        recursive_generator<int> g() {
            for (int x : f()) co_yield x;
        }
    \end{colorblock}

    Such a limitation can make it difficult to decide at the time of writing a generator
    coroutine whether or not you should return a \tcode{generator} or \tcode{recursive_generator}
    as you may not know at the time whether or not this particular generator will be used
    within \tcode{recursive_generator} or not.

    If you choose the \tcode{generator} return-type and then later someone wants to yield its
    elements from a \tcode{recursive_generator} then you either need to manually yield its
    elements one-by-one or use a helper function that adapts the \tcode{generator} into a
    \tcode{recursive_generator}. Both of these options can add runtime cost compared to the case where the generator was originally written to return a \tcode{recursive_generator},
    as it requires two coroutine resumptions per element instead of a single coroutine resumption.

    Because of these limitations, we are not recommending this approach.
\end{itemize}

Symmetric transfer is possible for different generator types as long as the \tcode{reference} type is the same, aka,
different value type or allocator type does not preclude symmetric transfer (see the section on allocators).

\section{Allocator support}

In line with the design exploration done in section 2 of \paper{P1681R0}, \tcode{std::generator} supports both stateless and stateful allocators and strives to minimize the interface verbosity for stateless allocators by templating both the generator itself and the \tcode{promise_type}'s \tcode{new} operator
on the allocator type. Details for this interface are found in \paper{P1681R0}.

\tcode{coroutine_parameter_preview_t} such as discussed in section 3 of \paper{P1681R0} has not been explored in this paper.

\begin{colorblock}
    std::generator<int> stateless_example() {
        co_yield 42;
    }

    template <class Allocator>
    std::generator<int> allocator_example(std::allocator_arg_t, Allocator alloc) {
        co_yield 42;
    }

    my_allocator<std::byte> alloc;
    input_range auto rng = allocator_example<my_allocator<std::byte>>(std::allocator_arg, alloc);
\end{colorblock}

The proposed interface requires that, if an allocator is provided, it is the second argument to the coroutine function,
immediately preceded by an instance of \tcode{std::allocator_arg_t}.
This approach is necessary to distinguish the allocator desired to allocate the coroutine state from allocators whose purpose is to be used in the body of the coroutine function.
The required argument order might be a limitation if any other argument is required to be the first. However, we cannot think of any scenario where that would be the case.

We think it is important that all standard and user coroutines types can accommodate similar interfaces for allocator support.
In fact, the implementation for that allocator support can be shared amongst \tcode{generator}, \tcode{lazy}, and other standard types.

\textbf{By default \tcode{std::generator} type erases the allocator type, and uses \tcode{std::allocator} unless an allocator is provided to
the coroutine function}.
Then:

\textbf{Type erased allocator(default)}

\begin{colorblock}
template <class Allocator>
std::generator<int> f(std::allocator_arg_t, Allocator alloc) {}

f(std::allocator_arg, my_alloc{});
\end{colorblock}

Returns a generator of type \tcode{std::generator<int, const int\&, void>}
where \tcode{void} denotes that the allocator is type erased.
The allocator is stored in the same allocation as the coroutine state
if it is stateful or not default constructible; a pointer is always stored so that
the \tcode{deallocate} method of the type erased allocator can be called.

\textbf{No allocator}

\begin{colorblock}
std::generator<int> f() {}
f();
\end{colorblock}

Again, returns a generator of type \tcode{std::generator<int, const int\&, void>}
where \tcode{void} denotes that the allocator is type erased.
A pointer is stored so that
the \tcode{deallocate} method
of the type-erased allocator can be called,
but the default allocator (\tcode{std::allocator})
need not be stored since it is stateless.

\textbf{Explicit stateless allocator}

\begin{colorblock}
std::generator<int, const int&, std::stateless_allocator<int>> f() {}
f();
\end{colorblock}

Returns a generator of type \tcode{std::generator<int, const int\&, std::stateless_allocator<int>>}
No extra storage is used for the allocator because it is stateless.

\textbf{Explicit stateful allocator}

\begin{colorblock}
std::generator<int, const int\&, some_stateful_allocator<int>>
    f(std::allocator_arg_t, some_stateful_allocator<int> alloc) {}
f(std::allocator_arg, some_allocator); // must be convertible to some_stateful_allocator
\end{colorblock}

Returns a generator of type \tcode{std::generator<int, const int\&, some_stateful_allocator<int>>}
The allocator is copied in the coroutine state.


\subsection{Interaction with symmetric transfer and allocator support}

The allocator must necessarily be part of a coroutine's promise type
since implementations query the promise for allocation functions.

Our implementation uses a base class to implement the non-allocation behaviors
for \tcode{generator}'s promise so that generators with different allocator types
can yield each other.

This leaves with two implementation strategies
\begin{itemize}
\item Storing a pointer to the base class in the promise handle
\item Leave implementers find the best implementation strategy and can bell their own implementation to be well-formed
\item Modify the wording as follow to allow \tcode{coroutine_handle<promise_base>::from_address(coro.address());} to be well-formed:
\end{itemize}

To support yielding nested generators with different allocator types we then have several options:
\begin{itemize}
\item Leaving implementers find the best strategy with compiler magic
\item Modify \tcode{coroutine_handle<T>::from_address}:
\end{itemize}
\begin{quote}
\indexlibrarymember{from_address}{coroutine_handle}%
\begin{itemdecl}
static constexpr coroutine_handle<Promise> coroutine_handle<Promise>::from_address(void* addr);
\end{itemdecl}

\begin{itemdescr}
\expects
\tcode{addr} was obtained via a prior call to \tcode{address}
on an object of type \cv \changed{\tcode{coroutine_handle<Promise>}}{of type \cv \tcode{coroutine_­handle<T}> where\tcode{T} is any type such that \tcode{is_layout_compatible_v<T, Promise>} is \tcode{true}}.
\end{itemdescr}
\end{quote}

\subsection{Can we postpone adding support for allocator later?}

A case can be made that allocator support could be added to \tcode{std::generator} later.
However, because the proposed design has the allocator as a template parameter,
adding allocator after \tcode{std::generator} ships would represent an ABI break.
We recommend that we add allocator support as proposed in this paper now and make sure that the design remains consistent as work on \tcode{std::lazy}
is made in this cycle.
However, it would be possible to extend support for different mechanisms (such as presented in section 3 of \paper{P1681R0} later.

\section{Implementation and experience}

\tcode{generator} has been provided as part of cppcoro and folly.
However, cppcoro offers a separate \tcode{recursive_generator} type, which is different than the proposed design.

Folly uses a single \tcode{generator} type, which can be recursive but doesn't implement symmetric transfer. Despite that,
Folly users found the use of \tcode{Folly:::Generator} to be a lot more efficient than the eager algorithm they replaced with it.

\tcode{ranges-v3} also implements a \tcode{generator} type, which is never recursive and predates the work on move-only views and
iterators \cite{P1456R1}, \cite{P1207R0} which forces this implementation to ref-count the coroutine handler.

Our implementation \cite{Implementation} consists of a single type that takes advantage of symmetric transfer to implement
recursion - it notably works well with three different major standard libraries.

\section{Performance \& benchmarks}

\begin{note}
These benchmark results are fairly dated now - roughly a year old - and should be taken with a grain of salt.
\end{note}

Because implementations are still being perfected, and because performance is extremely dependant on whether HALO optimization (see \paper{P0981R0})
occurs, it is difficult at this time to make definitive statements about the performance of the proposed design.

At the time of the writing of this paper, Clang is able to inline non-nested coroutines whether the implementation
supports nested coroutines or not, while GCC never performs HALO optimization.

When the coroutine is not inlined, support for recursion does not noticeably impact performance.
And, when the coroutine yields another generator, the performance of the recursive version is noticeably faster than
yielding each element of the range. This is especially noticeable with deep recursion.

\begin{adjustbox}{center}
\texttt{
\begin{threeparttable}
\begin{tabular}{|l?r|r?r|r?r|r|}
    \hline
    & Clang & Clang ST\tnote{1} & GCC & GCC ST\tnote{1} & MSVC & MSVC ST\tnote{1} \\
    \hline
    Single value & (1) 0.235 &  (2) 2.36 & 12.4 & 13.4 & 61.9 & 63.7 \\
    \hline
    Single value, noinline (3) & 13.5  & 13.7 & 14.1 & 15.2 & 63.8 & 64.4\\
    \hline
    Deep nesting & 43670266.0 & (4) 427955.0 & 58801348 & 338736 & 224052033 & 4760914\\
    \hline
\end{tabular}
\begin{tablenotes}
\item[1] Symmetric transfer.
\end{tablenotes}
\end{threeparttable}
}
\end{adjustbox}


The values are expressed in nanoseconds. However, please note that the comparison of the same result across compiler is not meaningful, notably because the MSVC results were obtained on different hardware.
That being said, we observe:

\begin{itemize}
    \item Only Clang can perform constant folding of values yielded by simple coroutine (1)
    \item When the \tcode{generator} supports symmetric transfer, clang is not able to fully inline the generator construction, but HALO is still performed (2).
    \item When HALO is not performed, the relative performance of both approaches is similar (3).
    \item Supporting recursion is greatly beneficial to nested/recursive algorithms (4).
\end{itemize}

The code for these benchmarks, as well as more detailed results, can be found on \href{https://github.com/cor3ntin/coro_benchmark}{Github}.


\section{Wording}

Drafting Note: Wording is relative to Working Draft N4901 \cite{N4901}. Add the declaration of \tcode{ranges::elements_of} to the \tcode{<ranges>} synopsis:

\rSec2[ranges.syn]{Header \tcode{<ranges>} synopsis}

\begin{codeblock}
namespace std::ranges {
    [...]

    template<@\libconcept{input_or_output_iterator}@ I, @\libconcept{sentinel_for}@<I> S, subrange_kind K>
    inline constexpr bool enable_borrowed_range<subrange<I, S, K>> = true;

    // [range.dangling], dangling iterator handling
    struct dangling;

\end{codeblock}
\begin{addedblock}
\begin{codeblock}
    // [elementsof.overview], class template elements_of
    template<range R, class Allocator = allocator<byte>>
    class elements_of;
\end{codeblock}
\end{addedblock}
\begin{codeblock}
    template<@\libconcept{range}@ R>
    using borrowed_iterator_t = conditional_t<@\libconcept{borrowed_range}@<R>, iterator_t<R>, dangling>;

    [...]
}
\end{codeblock}

Drafting Note: insert the following new subclause immediately after [range.dangling]:

\begin{addedblock}

\rSec2[ranges.elementsof]{class template \tcode{elements_of}}

\rSec3[ranges.elementsof.overview]{Overview}

Specializations of \tcode{elements_of} encapsulate a range and
act as a tag in overload sets to disambiguate
when a range should be treated as a sequence
rather than a single value.

\begin{example}
    \begin{codeblock}
        std::generator<any> f(std::ranges::input_range auto&& rng) {
            co_yield rng; // yield rng as a single value
            co_yield std::ranges::elements_of(rng); // yield each element of rng
        }
    \end{codeblock}
\end{example}

\begin{codeblock}
namespace std::ranges {
    template<range R, class Allocator = allocator<byte>>
    class elements_of {
    private:
        [[no_unique_address]] Allocator allocator_{}; // \expos
        R&& range_; // \expos

    public:
        constexpr explicit elements_of(R&& r)
            noexcept(is_nothrow_default_constructible_v<Allocator>)
            requires default_initializable<Allocator>;

        constexpr explicit elements_of(R&& r, Allocator allocator) noexcept;

        constexpr elements_of(elements_of&&) = default;
        elements_of(const elements_of&) = delete;

        constexpr R&& range() noexcept;
        constexpr Allocator get_allocator() const noexcept;
    };

    template<class R, class Allocator = allocator<byte>>
    elements_of(R&&, Allocator = {}) -> elements_of<R, Allocator>;
}
\end{codeblock}

\rSec3[ranges.elementsof.mem]{Members}

\begin{itemdecl}
constexpr explicit elements_of(R&& r) noexcept
    noexcept(is_nothrow_default_constructible_v<Allocator>)
    requires default_initializable<Allocator>;
\end{itemdecl}

\begin{itemdescr}
\effects
Initializes \tcode{range_} with \tcode{std::forward<R>(r)}.
\end{itemdescr}

\begin{itemdecl}
constexpr explicit elements_of(R&& r, Allocator allocator) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects
Initializes \tcode{allocator_} with \tcode{std::move(allocator)} and
\tcode{range_} with \tcode{std::forward<R>(r)}.
\end{itemdescr}

\begin{itemdecl}
constexpr R&& range() noexcept;
\end{itemdecl}

\begin{itemdescr}
\returns
\tcode{std::forward<R>(range_)}.
\end{itemdescr}

\begin{itemdecl}
constexpr Allocator get_allocator() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\returns
\tcode{allocator_}.
\end{itemdescr}

\rSec2[generator.syn]{Header \tcode{<generator>} synopsis}

FIXME: Where in the working draft does this go?

\begin{codeblock}
#include <coroutine>
#include <ranges>

namespace std {
    template<class Value, class Reference = const Value&, class Allocator = void>
    class generator;

    template<class Value, class Reference, class Allocator>
    inline constexpr bool ranges::enable_view<generator<Value, Reference, Allocator>> = true;
}
\end{codeblock}


\rSec2[coroutine.generator]{Generator View}

\rSec3[coroutine.generator.overview]{Overview}

\tcode{generator} generates a sequence of elements by repeatedly resuming the coroutine it was returned from.
When the coroutine is resumed, it is executed until it reaches either a \tcode{co_yield} expression or the end of the coroutine.

Elements of the sequence are produced by the coroutine each time a \tcode{co_yield} expression is evaluated.

When the \tcode{co_yield} expression is of the form \tcode{co_yield elements_of(rng)}, each element of the range \tcode{rng} is successively produced
as an element of the generator.

Specializations of \tcode{generator} model \tcode{view} and \tcode{input_range}.


\begin{example}
    \begin{codeblock}
        std::generator<int> iota(int start = 0) {
            while (true)
                co_yield start++;
        }

        void f() {
            for (auto i : iota() | std::views::take(3))
                std::cout << i << ' '; // prints 0 1 2
        }
    \end{codeblock}
\end{example}


\rSec3[coroutine.generator.class]{Class template \tcode{generator}}

\begin{codeblock}
namespace std {
    template<class Ref, Value = remove_cvref_t<Ref>, class Allocator = void>
        requires common_reference_with<Ref&&, Value&>
    class generator {
        class iterator; // \expos

    public:
        class promise_type;

        generator(const generator&) = delete;
        generator(generator&& other) noexcept;

        ~generator();

        generator& operator=(const generator&) = delete;
        generator& operator=(generator&& other) noexcept;

        iterator begin();
        default_sentinel_t end() const noexcept;

    private:
        explicit generator(coroutine_handle<promise_type> coroutine) noexcept; // \expos

        coroutine_handle<promise_type> coroutine_ = nullptr; // \expos
    };
}
\end{codeblock}

\begin{itemize}
\item \tcode{coroutine_traits<generator<Ref, Value, Allocator>>::promise_type} is valid and denotes a type,
\item \tcode{Allocator} either meets the \tcode{Cpp17Allocator} requirements or is \tcode{void}.
\end{itemize}

\begin{itemdecl}
generator(coroutine_handle<promise_type> coro) noexcept;
\end{itemdecl}

\begin{itemdescr}
Initializes \tcode{coroutine_} with \tcode{coro}.
\end{itemdescr}

\begin{itemdecl}
generator(generator&& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
Initializes \tcode{coroutine_} with \tcode{exchange(other.coroutine_, \{\})}.
\end{itemdescr}

\begin{itemdecl}
~generator();
\end{itemdecl}

\begin{itemdescr}
\effects
Equivalent to:
\begin{codeblock}
    if (coroutine_) {
        coroutine_.destroy();
    }
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
generator& operator=(generator&& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects
Equivalent to:
\tcode{coro_ = exchange(other.coro_, \{\})}.

\returns
\tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
iterator begin();
\end{itemdecl}

\begin{itemdescr}
\preconditions
\tcode{coroutine_} refers to a coroutine suspended at its initial suspend-point.

\effects
Equivalent to:
\begin{codeblock}
    coroutine_.resume();
    return iterator(coroutine_);
\end{codeblock}

\begin{note}
    A program that calls \tcode{begin}
    more than once on the same coroutine
    has undefined behavior.
\end{note}
\end{itemdescr}

\begin{itemdecl}
default_sentinel_t end() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{default_sentinel}.
\end{itemdescr}


\rSec3[coroutine.generator.promise]{class \tcode{generator::promise_type}}

\begin{codeblock}

template<class Ref, class Value, class Allocator>
    requires common_reference_with<Ref&&, Value&>
class generator<Ref, Value, Allocator>::promise_type {

    friend generator;

    // \textbf{This doesn't work if Ref is a reference type}
    // \textbf{we either need some kind of wrapper (see manual_lifetime in our \\   implementation, or only store a pointer in all cases)}

    union {
        Ref value_; // \expos
    };

    void destruct_value_() { // \expos
        if constexpr(!is_lvalue_reference_v<Ref>) {
            value_.~decay_t<Ref>();
    }

public:
    generator get_return_object() noexcept;

    suspend_always initial_suspend() noexcept;

    auto final_suspend() noexcept; // FIXME: not specified

    @\unspec@ yield_value(const Ref& value) noexcept(is_nothrow_move_constructible_v<Ref>);

    template<convertible_to<Ref> T>
    @\unspec@ yield_value(T&& x) noexcept(is_nothrow_constructible_v<Ref, T>);

    template<class TVal, class TAlloc>
    @\unspec@ yield_value(elements_of<generator<Ref, TVal, TAlloc>> g) noexcept; // \seebelownc

    template<ranges::input_range R, class Allocator>
        requires convertible_to<ranges::range_reference_t<R>, Ref>
    @\unspec@ yield_value(elements_of<R, Allocator> rng); // \seebelownc

    void await_transform() = delete;

    void return_void() noexcept {}

    void unhandled_exception();

    static void* operator new(size_t size) requires same_as<Allocator, void>;
    static void* operator new(size_t size) requires default_initializable<Allocator>;

    template<class Alloc, class... Args>
    static void* operator new(size_t size, allocator_arg_t, Alloc& alloc, Args&...);

    template<class This, class Alloc, class... Args>
    static void* operator new(size_t size, This&, allocator_arg_t, Alloc& alloc, Args&...);

    static void operator delete(void* pointer, size_t size) noexcept;
};
\end{codeblock}




\begin{itemdecl}
generator get_return_object() noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects Equivalent to:
\begin{codeblock}
    return generator{coroutine_handle<promise_type>::from_promise(*this)};
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
suspend_always initial_suspend() noexcept;
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{\{\}}.
\end{itemdescr}


\begin{itemdecl}
@\unspec@ yield_value(const Ref& x)
    noexcept(is_nothrow_move_constructible_v<Ref>);
\end{itemdecl}
\begin{itemdecl}
template<convertible_to<Ref> T>
@\unspec@ yield_value(T&& x)
    noexcept(is_nothrow_constructible_v<Ref, T>);
\end{itemdecl}

\begin{itemdescr}
\effects
Initialises \tcode{value_} with \tcode{std::forward<T>(x)}.

\returns An implementation-defined awaitable type\footnote{FIXME: What's an "awaitable type"?}.
\end{itemdescr}


\begin{itemdecl}
template<class TVal, class TAlloc>
auto yield_value(elements_of<generator<Ref, TVal, TAlloc>> g) noexcept;
\end{itemdecl}

\begin{itemdescr}
\mandates \item \tcode{TAlloc} meets the \tcode{Cpp17Allocator} requirements.

\effects
Execution is transferred to the coroutine represented by \tcode{g.coroutine_} until its completion.
After \tcode{g.coroutine_} completes, the current coroutine is resumed.
If \tcode{g.coroutine_} completes with an exception, the exception is rethrown from the `co_yield` expression.

Variables with automatic storage duration in the scope of the coroutine represented by \tcode{g.coroutine_} are destroyed
before variables with automatic storage duration in the scope of the coroutine denoted by this coroutine.

\begin{note}
Generators can transfer control recursively.
\end{note}

\returns
An implementation-defined \tcode{awaitable} type\footnote{FIXME: ditto "What's an 'awaitable type'"; why is \tcode{awaitable} in code font?}
which takes ownership of the generator \tcode{g}.
\end{itemdescr}


\begin{itemdecl}
template<ranges::input_range R, class Allocator>
requires convertible_to<ranges::range_reference_t<R>, Ref>
auto yield_value(elements_of<R, Allocator> rng);
\end{itemdecl}

\begin{itemdescr}
\effects
Equivalent to:
\begin{codeblock}
{
    return yield_value(ranges::elements_of([](R&& rng, Allocator alloc)
    -> generator<Ref, Value, Allocator> {
        const auto itEnd = ranges::end(rng);
        for (auto it = ranges::begin(rng); it != itEnd ++it) {
            co_yield *it;
        }
    }(rng.range(), rng.get_allocator())));
}
\end{codeblock}

The return object is of an implementation-defined type \tcode{T} such that
\tcode{is_same_v<coroutine_traits<T>::promise_type, coroutine_traits<generator>::promise_type>} is \tcode{true}.
\end{itemdescr}

\begin{itemdecl}
void unhandled_exception();
\end{itemdecl}

\begin{itemdescr}
\effects Equivalent to: \tcode{throw;}
\end{itemdescr}

\begin{itemdecl}
static void* operator new(size_t size) requires same_as<Allocator, void>;
\end{itemdecl}

\begin{itemdescr}
\effects
Equivalent to: \tcode{return allocator<byte>\{\}::allocate(size);}
\end{itemdescr}

\begin{itemdecl}
static void* operator new(size_t size) requires default_initializable<Allocator>;
\end{itemdecl}

\begin{itemdescr}
\effects
Equivalent to:
\begin{codeblock}
Allocator alloc;
return allocator_traits<Allocator>::allocate(alloc, size);
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
template<class Alloc, class... Args>
static void* operator new(size_t size, allocator_arg_t, Alloc& alloc, Args&...);

template<class This, class Alloc, class... Args>
static void* operator new(size_t size, This&, allocator_arg_t, Alloc& alloc, Args&...);
\end{itemdecl}

\begin{itemdescr}

\mandates
\begin{itemize}
\item \tcode{same_as<Allocator, void> || convertible_to<Alloc, Allocator>} is \tcode{true},
\item \tcode{Alloc} meets the \tcode{Cpp17Allocator} requirements,
\end{itemize}

\effects Allocates the coroutine state with \tcode{Alloc}.

\begin{note}
If \tcode{allocator_traits<Alloc>::is_always_equal::value} is \tcode{false} or if \tcode{default_initializable<Alloc>} is \tcode{false}, \tcode{alloc} is stored in the allocation for the coroutine state.
\end{note}

\end{itemdescr}

\begin{itemdecl}
static void operator delete(void* pointer, size_t size) noexcept;
\end{itemdecl}

\begin{itemdescr}
Deallocate the coroutine state with an instance of the allocator equivalent to the one that was used to allocate it.
\end{itemdescr}

\rSec3[coroutine.generator.iterator]{Class template \tcode{generator::iterator}}

\begin{codeblock}

template<class Ref, class Value, class Allocator>
    requires common_reference_with<Ref&&, Value&>
class generator<Ref, Value, Allocator>::iterator {
private:
    coroutine_handle<promise_type> coroutine_; // \expos

public:
    using value_type = promise_type::value_type;
    using difference_type = ptrdiff_t;

    iterator(const iterator&) = delete;
    iterator(iterator&& other) noexcept;

    iterator& operator=(const iterator&) = delete;
    iterator& operator=(iterator&& other) noexcept;

    bool operator==(default_sentinel_t) const noexcept;

    iterator& operator++();
    void operator++(int);

    reference operator*() const noexcept(is_nothrow_copy_constructible_v<reference>);

private:
    friend class generator;
    explicit iterator(coroutine_handle<promise_type> coroutine) noexcept; // \expos
};

\end{codeblock}

\begin{itemdecl}
 iterator(iterator&& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects
Initializes \tcode{coroutine_} with \tcode{exchange(other.coroutine_, \{\})}.
\end{itemdescr}


\begin{itemdecl}
iterator& operator=(iterator&& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects
Equivalent to: \tcode{coroutine_ = exchange(other.coroutine_, \{\});}
\end{itemdescr}

\begin{itemdecl}
explicit iterator(coroutine_handle<promise_type> coroutine) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects
Initializes \tcode{coroutine_} with \tcode{coroutine}.
\end{itemdescr}


\begin{itemdecl}
bool operator==(default_sentinel_t) const noexcept
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{coroutine_.done()}.
\end{itemdescr}

\begin{itemdecl}
iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\precondition \tcode{coroutine_.done()} is \tcode{false}.

% \effects

\returns \tcode{return *this};

\end{itemdescr}
\begin{itemdecl}
void operator++(int);
\end{itemdecl}

\begin{itemdescr}
\precondition \tcode{coroutine_.done()} is \tcode{false}.

\effects
Equivalent to:
\begin{codeblock}
    (void)operator++();
\end{codeblock}
\end{itemdescr}


\begin{itemdecl}
reference operator*() const
  noexcept(noexcept(is_nothrow_copy_constructible_v<reference>));
\end{itemdecl}

\begin{itemdescr}
\precondition \tcode{coroutine_.done()} is \tcode{false}.

\effects
Equivalent to:
\begin{codeblock}
    return coroutine_.promise().value_;
\end{codeblock}
\end{itemdescr}


\end{addedblock}

\section{Feature test macro}

Insert into [version.syn]

\begin{addedblock}
\begin{codeblock}
    #define __cpp_lib_generator YYYYXXL // also in <generator>
\end{codeblock}
\end{addedblock}


\section{References}
\renewcommand{\section}[2]{}%
\bibliographystyle{plain}
\bibliography{wg21}

\begin{thebibliography}{9}
    \bibitem[CppCoro]{CppCoro}
    Lewis Baker
    \emph{CppCoro: A library of C++ coroutine abstractions for the coroutines TS}\newline
    \url{https://github.com/lewissbaker/cppcoro}

    \bibitem[Folly]{Folly}
    Facebook
    \emph{Folly: An open-source C++ library developed and used at Facebook}\newline
    \url{https://github.com/facebook/folly}


    \bibitem[range]{range-v3}
    Eric Niebler
    \emph{range-v3 Range library for C++14/17/20}\newline
    \url{https://github.com/ericniebler/range-v3}

    \bibitem[Implementation]{Implementation}
    Casey Carter, Lewis Baker, Corentin Jabot
    \emph{\tcode{std::generator} implementation}\newline
    \url{https://godbolt.org/z/7dTfPz9d6}

\end{thebibliography}

\end{document}
